<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Marten</name>
    </assembly>
    <members>
        <member name="T:Marten.AdvancedOperations">
            <summary>
            Access to advanced, rarely used features of IDocumentStore
            </summary>
        </member>
        <member name="M:Marten.AdvancedOperations.ResetHiloSequenceFloor``1(System.Int64)">
            <summary>
                Set the minimum sequence number for a Hilo sequence for a specific document type
                to the specified floor. Useful for migrating data between databases
            </summary>
            <typeparam name="T"></typeparam>
            <param name="floor"></param>
        </member>
        <member name="M:Marten.AdvancedOperations.ResetHiloSequenceFloor``1(System.String,System.Int64)">
            <summary>
                Set the minimum sequence number for a Hilo sequence for a specific document type
                to the specified floor. Useful for migrating data between databases
            </summary>
            <typeparam name="T"></typeparam>
            <param name="floor"></param>
        </member>
        <member name="P:Marten.AdvancedOperations.Clean">
            <summary>
                Used to remove document data and tables from the current Postgresql database
            </summary>
        </member>
        <member name="M:Marten.AdvancedOperations.FetchEventStoreStatistics(System.Threading.CancellationToken)">
            <summary>
            Fetch the current size of the event store tables, including the current value
            of the event sequence number
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.AdvancedOperations.AllProjectionProgress(System.Threading.CancellationToken)">
            <summary>
            Check the current progress of all asynchronous projections
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.AdvancedOperations.ProjectionProgressFor(Marten.Events.Daemon.ShardName,System.Threading.CancellationToken)">
            <summary>
            Check the current progress of a single projection or projection shard
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.AdvancedOperations.SourceCodeForCompiledQuery(System.Type)">
            <summary>
            Calculate the source code that would be generated to handle
            a compiled query class
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.AdvancedOperations.SourceCodeForDocumentType(System.Type)">
            <summary>
            Access the generated source code Marten is using for a given
            document type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.AdvancedOperations.SourceCodeForEventStore">
            <summary>
            See the code that Marten generates for the current configuration of the
            Event Store
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.AdvancedOperations.EventProjectionScenario(System.Action{Marten.Events.TestSupport.ProjectionScenario})">
            <summary>
            Marten's built in test support for event projections. Only use this in testing as
            it will delete existing event and projected aggregate data
            </summary>
            <param name="configuration"></param>
            <returns></returns>
        </member>
        <member name="F:Marten.BulkInsertMode.InsertsOnly">
            <summary>
            Default, fast mode. Will throw an exception if there are any duplicate id's with the existing data
            </summary>
        </member>
        <member name="F:Marten.BulkInsertMode.IgnoreDuplicates">
            <summary>
            Will ignore any documents that already exist in the underlying table storage
            </summary>
        </member>
        <member name="F:Marten.BulkInsertMode.OverwriteExisting">
            <summary>
            Will overwrite the values of any duplicate documents (last update wins)
            </summary>
        </member>
        <member name="T:Marten.ConnectionFactory">
            <summary>
            Default, simple implementation of IConnectionFactory
            </summary>
        </member>
        <member name="M:Marten.ConnectionFactory.#ctor(System.Func{System.String})">
            <summary>
            Supply a lambda that can resolve the connection string
            for a Postgresql database
            </summary>
            <param name="connectionSource"></param>
        </member>
        <member name="M:Marten.ConnectionFactory.#ctor(System.String)">
            <summary>
            Supply the connection string to the Postgresql database directly
            </summary>
            <param name="connectionString"></param>
        </member>
        <member name="T:Marten.DefaultRetryPolicy">
            <summary>
            Default retry policy, which accounts for <see cref="P:Npgsql.NpgsqlException.IsTransient"/>.
            </summary>
            <remarks>
            Based on example https://martendb.io/documentation/documents/advanced/retrypolicy/ by Joona-Pekka Kokko.
            </remarks>
        </member>
        <member name="M:Marten.DefaultRetryPolicy.Once(System.Func{System.Exception,System.Boolean},System.Func{System.Int32,System.TimeSpan})">
            <summary>
            Initializes a retry policy that will retry once after failure that matches the filter.
            </summary>
            <param name="filter">Optional filter when to apply, default to checking for <see cref="P:Npgsql.NpgsqlException.IsTransient"/></param>
            <param name="sleep">Optional sleep after exception, gets retry number 1-N as parameter, defaults to sleeping retry number seconds</param>
            <returns>The configured retry policy.</returns>
        </member>
        <member name="M:Marten.DefaultRetryPolicy.Twice(System.Func{System.Exception,System.Boolean},System.Func{System.Int32,System.TimeSpan})">
            <summary>
            Initializes a retry policy that will retry twice after failure that matches the filter.
            </summary>
            <param name="filter">Optional filter when to apply, default to checking for <see cref="P:Npgsql.NpgsqlException.IsTransient"/></param>
            <param name="sleep">Optional sleep after exception, gets retry number 1-N as parameter, defaults to sleeping retry number seconds</param>
            <returns>The configured retry policy.</returns>
        </member>
        <member name="M:Marten.DefaultRetryPolicy.Times(System.Int32,System.Func{System.Exception,System.Boolean},System.Func{System.Int32,System.TimeSpan})">
            <summary>
            Initializes a retry policy that will retry given amount of times after failure.
            </summary>
            <param name="maxRetryCount">How many times the operation will be retried on failure that matches the filter.</param>
            <param name="filter">Optional filter when to apply, default to checking for <see cref="P:Npgsql.NpgsqlException.IsTransient"/></param>
            <param name="sleep">Optional sleep after exception, gets retry number 1-N as parameter, defaults to sleeping retry number seconds</param>
            <returns>The configured retry policy.</returns>
        </member>
        <member name="T:Marten.DocumentStore">
            <summary>
                The main entry way to using Marten
            </summary>
        </member>
        <member name="M:Marten.DocumentStore.#ctor(Marten.StoreOptions)">
            <summary>
                Creates a new DocumentStore with the supplied StoreOptions
            </summary>
            <param name="options"></param>
        </member>
        <member name="M:Marten.DocumentStore.For(System.String)">
            <summary>
                Quick way to stand up a DocumentStore to the given database connection
                in the "development" mode for auto-creating schema objects as needed
                with the default behaviors
            </summary>
            <param name="connectionString"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.DocumentStore.For``1">
            <summary>
                Configures a DocumentStore for an existing StoreOptions type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.DocumentStore.For(System.Action{Marten.StoreOptions})">
            <summary>
                Configures a DocumentStore by defining the StoreOptions settings first
            </summary>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Events.Aggregation.IAggregationRuntime">
            <summary>
            Internal interface for runtime event aggregation
            </summary>
        </member>
        <member name="T:Marten.Events.Aggregation.AggregationRuntime`2">
            <summary>
            Internal base class for runtime event aggregation
            </summary>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TId"></typeparam>
        </member>
        <member name="T:Marten.Events.Aggregation.AsyncLiveAggregatorBase`1">
            <summary>
            Internal base type for live aggregators with at least one asynchronous method
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Marten.Events.Aggregation.IAggregateProjection">
            <summary>
            Internal service within aggregating projections
            </summary>
        </member>
        <member name="M:Marten.Events.Aggregation.IEventSlicer`2.SliceInlineActions(Marten.IQuerySession,System.Collections.Generic.IEnumerable{Marten.Events.StreamAction},Marten.Storage.ITenancy)">
            <summary>
            This is called by inline projections
            </summary>
            <param name="querySession"></param>
            <param name="streams"></param>
            <param name="tenancy"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Aggregation.IEventSlicer`2.SliceAsyncEvents(Marten.IQuerySession,System.Collections.Generic.List{Marten.Events.IEvent},Marten.Storage.ITenancy)">
            <summary>
            This is called by the asynchronous projection runner
            </summary>
            <param name="querySession"></param>
            <param name="events"></param>
            <param name="tenancy"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Events.Aggregation.SyncLiveAggregatorBase`1">
            <summary>
            Internal base class for purely synchronous live aggregators
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Marten.Events.Aggregation.ITenantSliceGroup`1.AddEvent(`0,Marten.Events.IEvent)">
            <summary>
            Add a single event to a single event slice by id
            </summary>
            <param name="id">The aggregate id</param>
            <param name="event"></param>
        </member>
        <member name="M:Marten.Events.Aggregation.ITenantSliceGroup`1.AddEvents(`0,System.Collections.Generic.IEnumerable{Marten.Events.IEvent})">
            <summary>
            Add many events to a single event slice by aggregate id
            </summary>
            <param name="id">The aggregate id</param>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.Aggregation.ITenantSliceGroup`1.AddEvents``1(System.Func{``0,`0},System.Collections.Generic.IEnumerable{Marten.Events.IEvent})">
            <summary>
            Add events to streams where each event of type TEvent applies to only
            one stream
            </summary>
            <param name="singleIdSource"></param>
            <param name="events"></param>
            <typeparam name="TEvent"></typeparam>
        </member>
        <member name="M:Marten.Events.Aggregation.ITenantSliceGroup`1.AddEvents``1(System.Func{``0,System.Collections.Generic.IEnumerable{`0}},System.Collections.Generic.IEnumerable{Marten.Events.IEvent})">
            <summary>
            Add events to streams where each event of type TEvent may be related to many
            different aggregates
            </summary>
            <param name="multipleIdSource"></param>
            <param name="events"></param>
            <typeparam name="TEvent"></typeparam>
        </member>
        <member name="T:Marten.Events.Aggregation.TenantSliceGroup`2">
            <summary>
            Intermediate grouping of events by tenant within the asynchronous projection support
            </summary>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TId"></typeparam>
        </member>
        <member name="T:Marten.Events.Projections.EventSlice`2">
            <summary>
            A grouping of events that will be applied to an aggregate of type TDoc
            with the identity TId
            </summary>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TId"></typeparam>
        </member>
        <member name="P:Marten.Events.Projections.EventSlice`2.ActionType">
            <summary>
            Is this action the start of a new stream or appending
            to an existing stream?
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.EventSlice`2.Id">
            <summary>
            The aggregate identity
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.EventSlice`2.Tenant">
            <summary>
            The current tenant
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.EventSlice`2.Aggregate">
            <summary>
            The related aggregate document
            </summary>
        </member>
        <member name="M:Marten.Events.Projections.EventSlice`2.AddEvent(Marten.Events.IEvent)">
            <summary>
            Add a single event to this slice
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Marten.Events.Projections.EventSlice`2.AddEvents(System.Collections.Generic.IEnumerable{Marten.Events.IEvent})">
            <summary>
            Add a grouping of events to this slice
            </summary>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.Projections.EventSlice`2.Events">
            <summary>
            All the events in this slice
            </summary>
        </member>
        <member name="T:Marten.Events.Projections.EventProjection">
            <summary>
            This is the "do anything" projection type
            </summary>
        </member>
        <member name="T:Marten.Events.Projections.EventProjection.ProjectMethodCollection">
            <summary>
            This would be a helper for the open ended EventProjection
            </summary>
        </member>
        <member name="T:Marten.Events.Projections.EventProjection.CreateMethodCollection">
            <summary>
            This would be a helper for the open ended EventProjection
            </summary>
        </member>
        <member name="T:Marten.Events.Projections.IAggregateGrouper`1">
            <summary>
            Plugin point to create custom event to aggregate grouping that requires database lookup
            as part of the sorting of events into aggregate slices
            </summary>
            <typeparam name="TId"></typeparam>
        </member>
        <member name="M:Marten.Events.Projections.IAggregateGrouper`1.Group(Marten.IQuerySession,System.Collections.Generic.IEnumerable{Marten.Events.IEvent},Marten.Events.Aggregation.ITenantSliceGroup{`0})">
            <summary>
            Apply custom grouping rules to apply events to one or many aggregates
            </summary>
            <param name="session"></param>
            <param name="events"></param>
            <param name="grouping"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Events.Projections.FanoutMode">
            <summary>
            When does the fanout rule apply?
            </summary>
        </member>
        <member name="F:Marten.Events.Projections.FanoutMode.BeforeGrouping">
            <summary>
            Do the "fan out" of events *before* doing any grouping
            </summary>
        </member>
        <member name="F:Marten.Events.Projections.FanoutMode.AfterGrouping">
            <summary>
            Do the "fan out" of events *after* grouping
            </summary>
        </member>
        <member name="T:Marten.Events.Projections.IProjection">
            <summary>
            Interface for all event projections
            </summary>
        </member>
        <member name="M:Marten.Events.Projections.IProjection.Apply(Marten.IDocumentOperations,System.Collections.Generic.IReadOnlyList{Marten.Events.StreamAction})">
            <summary>
            Apply inline projections during synchronous operations
            </summary>
            <param name="operations"></param>
            <param name="streams"></param>
        </member>
        <member name="M:Marten.Events.Projections.IProjection.ApplyAsync(Marten.IDocumentOperations,System.Collections.Generic.IReadOnlyList{Marten.Events.StreamAction},System.Threading.CancellationToken)">
            <summary>
            Apply inline projections during asynchronous operations
            </summary>
            <param name="operations"></param>
            <param name="streams"></param>
            <param name="cancellation"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Events.Projections.MultiStreamGrouper`2">
            <summary>
            This type of grouper potentially sorts one event into multiple aggregates
            </summary>
            <typeparam name="TId"></typeparam>
            <typeparam name="TEvent"></typeparam>
        </member>
        <member name="T:Marten.Events.Projections.ProjectionOptions">
            <summary>
            Used to register projections with Marten
            </summary>
        </member>
        <member name="M:Marten.Events.Projections.ProjectionOptions.Add(Marten.Events.Projections.IProjection,Marten.Events.Projections.ProjectionLifecycle,System.String,System.Action{Marten.Events.Daemon.AsyncOptions})">
            <summary>
            Register a projection to the Marten configuration
            </summary>
            <param name="projection">Value values are Inline/Async, The default is Inline</param>
            <param name="lifecycle"></param>
            <param name="projectionName">Overwrite the named identity of this projection. This is valuable if using the projection asynchonously</param>
            <param name="asyncConfiguration">Optional configuration including teardown instructions for the usage of this projection within the async projection daempon</param>
        </member>
        <member name="M:Marten.Events.Projections.ProjectionOptions.Add(Marten.Events.Projections.EventProjection,System.Nullable{Marten.Events.Projections.ProjectionLifecycle})">
            <summary>
            Add a projection that will be executed inline
            </summary>
            <param name="projection"></param>
            <param name="lifecycle">Optionally override the lifecycle of this projection. The default is Inline</param>
        </member>
        <member name="M:Marten.Events.Projections.ProjectionOptions.SelfAggregate``1(System.Nullable{Marten.Events.Projections.ProjectionLifecycle})">
            <summary>
            Use a "self-aggregating" aggregate of type.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="lifecycle">Override the aggregate lifecycle. The default is Inline</param>
            <returns>The extended storage configuration for document T</returns>
        </member>
        <member name="M:Marten.Events.Projections.ProjectionOptions.Add``1(System.Nullable{Marten.Events.Projections.ProjectionLifecycle})">
            <summary>
            Register an aggregate projection that should be evaluated inline
            </summary>
            <typeparam name="TProjection">Projection type</typeparam>
            <param name="lifecycle">Optionally override the ProjectionLifecycle</param>
            <returns>The extended storage configuration for document T</returns>
        </member>
        <member name="M:Marten.Events.Projections.ProjectionOptions.Add``1(Marten.Events.Aggregation.AggregateProjection{``0},System.Nullable{Marten.Events.Projections.ProjectionLifecycle})">
            <summary>
            Register an aggregate projection that should be evaluated inline
            </summary>
            <param name="projection"></param>
            <typeparam name="T"></typeparam>
            <param name="lifecycle">Optionally override the ProjectionLifecycle</param>
            <returns>The extended storage configuration for document T</returns>
        </member>
        <member name="F:Marten.Events.Projections.ProjectionLifecycle.Inline">
            <summary>
            The projection will be updated in the same transaction as
            the events being captured
            </summary>
        </member>
        <member name="F:Marten.Events.Projections.ProjectionLifecycle.Async">
            <summary>
            The projection will only execute within the Async Daemon
            </summary>
        </member>
        <member name="F:Marten.Events.Projections.ProjectionLifecycle.Live">
            <summary>
            The projection is only executed on demand
            </summary>
        </member>
        <member name="T:Marten.Events.Projections.IProjectionSource">
            <summary>
            Read-only diagnostic view of a registered projection
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.IProjectionSource.ProjectionName">
            <summary>
            The configured projection name used within the Async Daemon
            progress tracking
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.IProjectionSource.Lifecycle">
            <summary>
            When is this projection executed?
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.IProjectionSource.ProjectionType">
            <summary>
            The concrete .Net type implementing this projection
            </summary>
        </member>
        <member name="M:Marten.Events.Projections.IProjectionSource.PublishedTypes">
            <summary>
            This is *only* a hint to Marten about what projected document types
            are published by this projection to aid the "generate ahead" model
            </summary>
            <returns></returns>
        </member>
        <member name="T:Marten.Events.Projections.ProjectionSource">
            <summary>
            Base type for projection types that operate by code generation
            </summary>
        </member>
        <member name="T:Marten.Events.Projections.SingleStreamGrouper`2">
            <summary>
            Assigns an event to only one stream
            </summary>
            <typeparam name="TId"></typeparam>
            <typeparam name="TEvent"></typeparam>
        </member>
        <member name="T:Marten.Events.Projections.SyncEventProjectionBase">
            <summary>
            Base class for event projections that are strictly synchronous
            </summary>
        </member>
        <member name="T:Marten.Events.Projections.SyncProjectionBase">
            <summary>
            Base class for projections that are strictly synchronous
            </summary>
        </member>
        <member name="T:Marten.Events.Projections.ViewProjection`2">
            <summary>
                Project a single document view across events that may span across
                event streams in a user-defined grouping
            </summary>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TId"></typeparam>
        </member>
        <member name="M:Marten.Events.Projections.ViewProjection`2.CustomGrouping(Marten.Events.Projections.IAggregateGrouper{`1})">
            <summary>
            Apply a custom event grouping strategy for events. This is additive to Identity() or Identities()
            </summary>
            <param name="grouper"></param>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Marten.Events.Projections.ViewProjection`2.CustomGrouping(Marten.Events.Aggregation.IEventSlicer{`0,`1})">
            <summary>
            If your grouping of events to aggregates doesn't fall into any simple pattern supported
            directly by ViewProjection, supply your own "let me do whatever I want" event slicer
            </summary>
            <param name="slicer"></param>
        </member>
        <member name="M:Marten.Events.Projections.ViewProjection`2.FanOut``2(System.Func{``0,System.Collections.Generic.IEnumerable{``1}},Marten.Events.Projections.FanoutMode)">
            <summary>
            Apply "fan out" operations to the given TEvent type that inserts an enumerable of TChild events right behind the parent
            event in the event stream
            </summary>
            <param name="fanOutFunc"></param>
            <param name="mode">Should the fan out operation happen after grouping, or before? Default is after</param>
            <typeparam name="TEvent"></typeparam>
            <typeparam name="TChild"></typeparam>
        </member>
        <member name="M:Marten.Events.Archiving.ArchivedEventExtensions.MaybeArchived(Marten.Events.IEvent)">
            <summary>
            Query for events regardless of whether they are marked
            as archived or not
            </summary>
            <param name="event"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Events.CodeGeneration.AggregateConstructorFrame">
            <summary>
            Calls the aggregate's single argument constructor for a specific
            event type
            </summary>
        </member>
        <member name="T:Marten.Events.CodeGeneration.CreateAggregateFrame">
            <summary>
                Calls an AggregatedProjection.Create() method
            </summary>
        </member>
        <member name="T:Marten.Events.CodeGeneration.EventProcessingFrame">
            <summary>
            Organizes a single Event type within a pattern
            matching switch statement
            </summary>
        </member>
        <member name="F:Marten.Events.Daemon.AgentStatus.Running">
            <summary>
            The projection shard is successfully processing new
            events
            </summary>
        </member>
        <member name="F:Marten.Events.Daemon.AgentStatus.Stopped">
            <summary>
            The projection shard has been completely stopped
            </summary>
        </member>
        <member name="F:Marten.Events.Daemon.AgentStatus.Paused">
            <summary>
            The projection shard has been temporarily paused due
            to failures and will be re-started after a set amount
            of time
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.AsyncOptions">
            <summary>
            Governs the advanced behavior of a projection shard running
            in the projection daemon
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.AsyncOptions.BatchSize">
            <summary>
            The maximum range of events fetched at one time
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.AsyncOptions.MaximumHopperSize">
            <summary>
            The maximum number of events to be held in memory in preparation
            for determining projection updates.
            </summary>
        </member>
        <member name="M:Marten.Events.Daemon.AsyncOptions.DeleteViewTypeOnTeardown``1">
            <summary>
            Add explicit teardown rule to delete all documents of type T
            when this projection shard is rebuilt
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Marten.Events.Daemon.AsyncOptions.DeleteViewTypeOnTeardown(System.Type)">
            <summary>
            Add explicit teardown rule to delete all documents of type T
            when this projection shard is rebuilt
            </summary>
            <param name="type"></param>
        </member>
        <member name="P:Marten.Events.Daemon.AsyncOptions.StorageTypes">
            <summary>
            Optional list of stored document or feature types that this projection
            writes. This is used by Marten to help build out schema objects if the
            async daemon is started before the rest of the application.
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.AsyncProjectionHostedService">
            <summary>
            Registered automatically by Marten if the async projection daemon is enabled
            to start and stop asynchronous projections on application start and shutdown
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.AsyncProjectionShard">
            <summary>
                Definition of a single projection shard to be executed asynchronously
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.AsyncProjectionShard.EventFilters">
            <summary>
                WHERE clause fragments used to filter the events
                to be applied to this projection shard
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.AsyncProjectionShard.Name">
            <summary>
                The identity of this projection shard
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.IReadOnlyDaemonSettings.StaleSequenceThreshold">
            <summary>
            If the projection daemon detects a "stale" event sequence that is probably cause
            by sequence numbers being reserved, but never committed, this is the threshold to say
            "just look for the highest contiguous sequence number newer than X amount of time" to trigger
            the daemon to continue advancing. The default is 3 seconds.
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.IReadOnlyDaemonSettings.SlowPollingTime">
            <summary>
            Polling time between looking for a new high water sequence mark
            if the daemon detects low activity. The default is 1 second.
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.IReadOnlyDaemonSettings.FastPollingTime">
            <summary>
            Polling time between looking for a new high water sequence mark
            if the daemon detects high activity. The default is 250ms
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.IReadOnlyDaemonSettings.HealthCheckPollingTime">
            <summary>
            Polling time for the running projection daemon to determine the health
            of its activities and try to restart anything that is not currently running
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.IReadOnlyDaemonSettings.AsyncMode">
            <summary>
            Projection Daemon mode. The default is Disabled
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.DaemonSettings.StaleSequenceThreshold">
            <summary>
            If the projection daemon detects a "stale" event sequence that is probably cause
            by sequence numbers being reserved, but never committed, this is the threshold to say
            "just look for the highest contiguous sequence number newer than X amount of time" to trigger
            the daemon to continue advancing. The default is 3 seconds.
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.DaemonSettings.SlowPollingTime">
            <summary>
            Polling time between looking for a new high water sequence mark
            if the daemon detects low activity. The default is 1 second.
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.DaemonSettings.FastPollingTime">
            <summary>
            Polling time between looking for a new high water sequence mark
            if the daemon detects high activity. The default is 250ms
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.DaemonSettings.HealthCheckPollingTime">
            <summary>
            Polling time for the running projection daemon to determine the health
            of its activities and try to restart anything that is not currently running
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.DaemonSettings.DaemonLockId">
            <summary>
            This is used to establish a global lock id for the async daemon and should
            be unique for any applications that target the same database.
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.DaemonSettings.AsyncMode">
            <summary>
            Projection Daemon mode. The default is Disabled
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.DaemonSettings.LeadershipPollingTime">
            <summary>
            Time in milliseconds to poll for leadership election in the async projection daemon
            </summary>
        </member>
        <member name="M:Marten.Events.Daemon.DaemonSettings.OnException``1">
            <summary>
                Specifies the type of exception that this policy can handle.
            </summary>
            <typeparam name="TException">The type of the exception to handle.</typeparam>
            <returns>The PolicyBuilder instance.</returns>
        </member>
        <member name="M:Marten.Events.Daemon.DaemonSettings.OnException(System.Func{System.Exception,System.Boolean})">
            <summary>
                Specifies the type of exception that this policy can handle with additional filters on this exception type.
            </summary>
            <typeparam name="TException">The type of the exception.</typeparam>
            <param name="policies"></param>
            <param name="exceptionPredicate">The exception predicate to filter the type of exception this policy can handle.</param>
            <returns>The PolicyBuilder instance.</returns>
        </member>
        <member name="M:Marten.Events.Daemon.DaemonSettings.OnApplyEventException">
            <summary>
            Specify an exception handling policy for failures due to a specific event
            within a projection shard
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.DaemonSettings.OnExceptionOfType(System.Type)">
            <summary>
                Specifies the type of exception that this policy can handle with additional filters on this exception type.
            </summary>
            <param name="policies"></param>
            <param name="exceptionType">An exception type to match against</param>
            <returns>The PolicyBuilder instance.</returns>
        </member>
        <member name="M:Marten.Events.Daemon.DaemonSettings.OnException``1(System.Func{``0,System.Boolean})">
            <summary>
                Specifies the type of exception that this policy can handle with additional filters on this exception type.
            </summary>
            <typeparam name="TException">The type of the exception.</typeparam>
            <param name="policies"></param>
            <param name="exceptionPredicate">The exception predicate to filter the type of exception this policy can handle.</param>
            <returns>The PolicyBuilder instance.</returns>
        </member>
        <member name="T:Marten.Events.Daemon.EventFetcher">
            <summary>
            Fetches ranges of event objects. Used within the asynchronous projections
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.EventFetcherException">
            <summary>
            Marten failed to load events for a projection shard
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.EventRange">
            <summary>
            Used to specify then track a range of events by sequence number
            within the asynchronous projections
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.EventRange.ShardName">
            <summary>
            Identifies the projection shard consuming this event range
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.EventRange.SequenceFloor">
            <summary>
            The non-inclusive lower bound of the event sequence numbers
            in this range
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.EventRange.SequenceCeiling">
            <summary>
            The inclusive upper bound of the event sequence numbers in this range
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.EventRange.Events">
            <summary>
            The actual events fetched for this range and the base filters of the projection
            shard
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.EventRange.Size">
            <summary>
            The actual number of events in this range
            </summary>
        </member>
        <member name="M:Marten.Events.Daemon.EventRangeGroup.Reset">
            <summary>
            Teardown any existing state. Used to clean off existing work
            before doing retries
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.EventTypeFilter">
            <summary>
            WHERE clause filter to limit event fetching to only the event types specified
            </summary>
        </member>
        <member name="F:Marten.Events.Daemon.GroupActionMode.Parent">
            <summary>
            If the action is at the parent level, you can skip events
            and retry from here
            </summary>
        </member>
        <member name="F:Marten.Events.Daemon.GroupActionMode.Child">
            <summary>
            If the action is at the child level, the daemon error handling
            cannot skip events at this level, but needs to be retried
            from the parent action level
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.HotColdCoordinator">
            <summary>
            Coordinate the async daemon in the case of hot/cold failover
            where only one node at a time should be running the async daemon
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.INodeCoordinator">
            <summary>
            Swappable coordinator for the async daemon that is
            responsible for starting projection shards and assigning
            work to the locally running IProjectionDaemon
            </summary>
        </member>
        <member name="M:Marten.Events.Daemon.INodeCoordinator.Start(Marten.Events.Daemon.IProjectionDaemon,System.Threading.CancellationToken)">
            <summary>
            Called at the start of the application to register the projection
            daemon with the coordinator
            </summary>
            <param name="daemon"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.INodeCoordinator.Stop">
            <summary>
            Called at application shutdown as a hook to perform
            any work necessary to take the current node down
            </summary>
            <returns></returns>
        </member>
        <member name="T:Marten.Events.Daemon.IProjectionDaemon">
            <summary>
            Starts, stops, and manages any running asynchronous projections
            </summary>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.RebuildProjection(System.String,System.Threading.CancellationToken)">
            <summary>
            Rebuilds a single projection by projection name inline
            </summary>
            <param name="projectionName"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.RebuildProjection``1(System.Threading.CancellationToken)">
            <summary>
            Rebuilds a single projection by projection type inline
            </summary>
            <typeparam name="TView">Projection view type</typeparam>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.StartShard(System.String,System.Threading.CancellationToken)">
            <summary>
            Starts a single projection shard by name
            </summary>
            <param name="shardName"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.StartShard(Marten.Events.Daemon.AsyncProjectionShard,System.Threading.CancellationToken)">
            <summary>
            Starts a single projection shard
            </summary>
            <param name="shard"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.StopShard(System.String,System.Exception)">
            <summary>
            Stops a single projection shard by name
            </summary>
            <param name="shardName"></param>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.StartAllShards">
            <summary>
            Starts all known projections shards
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.StopAll">
            <summary>
            Stops all known projection shards
            </summary>
            <returns></returns>
        </member>
        <member name="P:Marten.Events.Daemon.IProjectionDaemon.Tracker">
            <summary>
            Observable tracking of projection shard events
            </summary>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.StartDaemon">
            <summary>
            Starts the daemon high water detection. This is called
            automatically by any of the Start***() or Rebuild****()
            methods
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.WaitForNonStaleData(System.TimeSpan)">
            <summary>
            Use with caution! This will try to wait for all projections to "catch up" to the currently
            known farthest known sequence of the event store
            </summary>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Events.Daemon.IShardAgent">
            <summary>
            Used internally by asynchronous projections.
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.ProjectionController">
            <summary>
            Helps control the "pull-based" event loading in an individual projection shard
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.ProjectionDaemon">
            <summary>
                The main class for running asynchronous projections
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.ProjectionDocumentSession">
            <summary>
            Lightweight session specifically used to capture operations for a specific tenant
            in the asynchronous projections
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.ProjectionUpdateBatch">
            <summary>
            Incrementally built batch command for projection updates
            </summary>
        </member>
        <member name="F:Marten.Events.Daemon.Resiliency.DaemonMode.Disabled">
            <summary>
            The projection daemon is disabled in this Marten application and
            will not be started as part of the application
            </summary>
        </member>
        <member name="F:Marten.Events.Daemon.Resiliency.DaemonMode.Solo">
            <summary>
            Marten will start up the complete projection daemon with the assumption
            that this node is the only execution node. This is appropriate for single
            node deployments and local development usage
            </summary>
        </member>
        <member name="F:Marten.Events.Daemon.Resiliency.DaemonMode.HotCold">
            <summary>
            Marten will ensure that the full async projection daemon will only execute on
            one node at a time, with fail over to other nodes.
            </summary>
        </member>
        <member name="M:Marten.Events.Daemon.Resiliency.ExceptionPolicy.AndInner(System.Func{System.Exception,System.Boolean})">
            <summary>
            Specifies an additional type of exception that this policy can handle with additional filters on this exception type.
            </summary>
            <param name="exceptionPredicate">The exception predicate to filter the type of exception this policy can handle.</param>
            <returns>The PolicyBuilder instance.</returns>
        </member>
        <member name="M:Marten.Events.Daemon.Resiliency.ExceptionPolicy.AndInner``1(System.Func{``0,System.Boolean})">
            <summary>
            Specifies an additional type of exception that this policy can handle with additional filters on this exception type.
            </summary>
            <typeparam name="TException">The type of the exception.</typeparam>
            <param name="exceptionPredicate">The exception predicate to filter the type of exception this policy can handle.</param>
            <returns>The PolicyBuilder instance.</returns>
        </member>
        <member name="M:Marten.Events.Daemon.Resiliency.ExceptionPolicy.AndInner``1">
            <summary>
                Specifies an additional type of exception that this policy can handle if found as an InnerException of a regular
                <see cref="T:System.Exception" />, or at any level of nesting within an <see cref="T:System.AggregateException" />.
            </summary>
            <typeparam name="TException">The type of the exception to handle.</typeparam>
            <returns>The PolicyBuilder instance, for fluent chaining.</returns>
        </member>
        <member name="M:Marten.Events.Daemon.Resiliency.ExceptionPolicy.Pause(System.TimeSpan)">
            <summary>
            Pause the execution of the current projection shard
            for the defined amount of time before attempting to restart
            </summary>
            <param name="timeSpan"></param>
        </member>
        <member name="M:Marten.Events.Daemon.Resiliency.ExceptionPolicy.PauseAll(System.TimeSpan)">
            <summary>
            Pause all running projection shards for the defined amount
            of time before attempting to restart
            </summary>
            <param name="timeSpan"></param>
        </member>
        <member name="M:Marten.Events.Daemon.Resiliency.ExceptionPolicy.Stop">
            <summary>
            Stop the running projection shard
            </summary>
        </member>
        <member name="M:Marten.Events.Daemon.Resiliency.ExceptionPolicy.StopAll">
            <summary>
            Stop all running projections shards
            </summary>
        </member>
        <member name="M:Marten.Events.Daemon.Resiliency.ExceptionPolicy.DoNothing">
            <summary>
            Ignore the exception and do nothing
            </summary>
        </member>
        <member name="M:Marten.Events.Daemon.Resiliency.ICoreHandlerDefinition.Pause(System.TimeSpan)">
            <summary>
            Pause the execution of the current projection shard
            for the defined amount of time before attempting to restart
            </summary>
            <param name="timeSpan"></param>
        </member>
        <member name="M:Marten.Events.Daemon.Resiliency.ICoreHandlerDefinition.PauseAll(System.TimeSpan)">
            <summary>
            Pause all running projection shards for the defined amount
            of time before attempting to restart
            </summary>
            <param name="timeSpan"></param>
        </member>
        <member name="M:Marten.Events.Daemon.Resiliency.ICoreHandlerDefinition.Stop">
            <summary>
            Stop the running projection shard
            </summary>
        </member>
        <member name="M:Marten.Events.Daemon.Resiliency.ICoreHandlerDefinition.StopAll">
            <summary>
            Stop all running projections shards
            </summary>
        </member>
        <member name="M:Marten.Events.Daemon.Resiliency.ICoreHandlerDefinition.DoNothing">
            <summary>
            Ignore the exception and do nothing
            </summary>
        </member>
        <member name="M:Marten.Events.Daemon.Resiliency.ICoreHandlerDefinition.SkipEvent">
            <summary>
            Make the async projection daemon re-run the current page of events,
            but skip the event that caused the ApplyEventException. If the event
            that caused the exception cannot be determined, the current projection
            shard will be stopped.
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.Resiliency.IThenExpression.Then">
            <summary>
            Define the next operation after retrying
            a set number of times
            </summary>
        </member>
        <member name="M:Marten.Events.Daemon.Resiliency.IHandlerDefinition.RetryLater(System.TimeSpan[])">
            <summary>
            Set a limited number of retry attempts for matching exceptions.
            Can be used to specify an exponential backoff strategy
            </summary>
            <param name="timeSpans"></param>
            <returns></returns>
        </member>
        <member name="F:Marten.Events.Daemon.ShardAction.Updated">
            <summary>
            The projection shard updated successfully
            </summary>
        </member>
        <member name="F:Marten.Events.Daemon.ShardAction.Started">
            <summary>
            The projection shard was successfully started
            </summary>
        </member>
        <member name="F:Marten.Events.Daemon.ShardAction.Stopped">
            <summary>
            The projection shard was stopped
            </summary>
        </member>
        <member name="F:Marten.Events.Daemon.ShardAction.Paused">
            <summary>
            The projection shard was paused and will be restarted
            after a set amount of time based on error handling policies
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.ShardAgent">
            <summary>
            Responsible for running a single async projection shard at runtime. Equivalent to V3 ProjectionTrack
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.ShardName">
            <summary>
            Identity for a single async shard
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.ShardName.ProjectionName">
            <summary>
            Parent projection name
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.ShardName.Key">
            <summary>
            The identity of the shard within the projection. If there is only
            one shard for a projection, this will be "All"
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.ShardName.Identity">
            <summary>
            {ProjectionName}:{Key}. Single identity string that should be unique within this Marten application
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.ShardStartException">
            <summary>
            A projection shard failed to start
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.ShardState">
            <summary>
            Point in time state of a single projection shard or the high water mark
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.ShardState.Timestamp">
            <summary>
            Time this state was recorded
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.ShardState.ShardName">
            <summary>
            Name of the projection shard
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.ShardState.Sequence">
            <summary>
            Furthest event sequence number processed by this projection shard
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.ShardState.Exception">
            <summary>
            If not null, this is the exception that caused this state to be published
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.ShardStateTracker">
            <summary>
            Observable for progress and action updates for all running asynchronous projection shards
            </summary>
        </member>
        <member name="M:Marten.Events.Daemon.ShardStateTracker.Subscribe(System.IObserver{Marten.Events.Daemon.ShardState})">
            <summary>
            Register a new observer of projection shard events. The return disposable
            can be used to unsubscribe the observer from the tracker
            </summary>
            <param name="observer"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.Events.Daemon.ShardStateTracker.HighWaterMark">
            <summary>
            Currently known "high water mark" denoting the highest complete sequence
            of the event storage
            </summary>
        </member>
        <member name="M:Marten.Events.Daemon.ShardStateTracker.WaitForShardState(Marten.Events.Daemon.ShardState,System.Nullable{System.TimeSpan})">
            <summary>
            Use to "wait" for an expected projection shard state
            </summary>
            <param name="expected"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.ShardStateTracker.WaitForShardState(System.String,System.Int64,System.Nullable{System.TimeSpan})">
            <summary>
            Use to "wait" for an expected projection shard state
            </summary>
            <param name="shardName"></param>
            <param name="sequence"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.ShardStateTracker.WaitForShardState(Marten.Events.Daemon.ShardName,System.Int64,System.Nullable{System.TimeSpan})">
            <summary>
            Use to "wait" for an expected projection shard state
            </summary>
            <param name="name"></param>
            <param name="sequence"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.ShardStateTracker.WaitForShardCondition(System.Func{Marten.Events.Daemon.ShardState,System.Boolean},System.String,System.Nullable{System.TimeSpan})">
            <summary>
            Use to "wait" for an expected projection shard condition
            </summary>
            <param name="condition"></param>
            <param name="description"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.ShardStateTracker.WaitForHighWaterMark(System.Int64,System.Nullable{System.TimeSpan})">
            <summary>
            Wait for the high water mark to attain the given sequence number
            </summary>
            <param name="sequence"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Events.Daemon.ShardStatusWatcher">
            <summary>
            Used mostly by tests to listen for expected shard events or progress
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.ShardStopException">
            <summary>
            A projection shard failed to stop in a timely manner
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.SoloCoordinator">
            <summary>
            Default projection coordinator, assumes that there is only one
            single node
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.Id">
            <summary>
            Unique identifier for the event. Uses a sequential Guid
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.Version">
            <summary>
            The version of the stream this event reflects. The place in the stream.
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.Sequence">
            <summary>
            The sequential order of this event in the entire event store
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.Data">
            <summary>
                The actual event data body
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.StreamId">
            <summary>
                If using Guid's for the stream identity, this will
                refer to the Stream's Id, otherwise it will always be Guid.Empty
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.StreamKey">
            <summary>
                If using strings as the stream identifier, this will refer
                to the containing Stream's Id
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.Timestamp">
            <summary>
                The UTC time that this event was originally captured
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.TenantId">
            <summary>
                If using multi-tenancy by tenant id
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.EventType">
            <summary>
            The .Net type of the event body
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.EventTypeName">
            <summary>
            Marten's type alias string for the Event type
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.DotNetTypeName">
            <summary>
            Marten's string representation of the event type
            in assembly qualified name
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.CausationId">
            <summary>
            Optional metadata describing the causation id
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.CorrelationId">
            <summary>
            Optional metadata describing the correlation id
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.Headers">
            <summary>
            Optional user defined metadata values. This may be null.
            </summary>
        </member>
        <member name="M:Marten.Events.IEvent.SetHeader(System.String,System.Object)">
            <summary>
            Set an optional user defined metadata value by key
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Marten.Events.IEvent.GetHeader(System.String)">
            <summary>
            Get an optional user defined metadata value by key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.Events.IEvent.IsArchived">
            <summary>
            Has this event been archived and no longer applicable
            to projected views
            </summary>
        </member>
        <member name="P:Marten.Events.Event`1.Data">
            <summary>
                The actual event data
            </summary>
        </member>
        <member name="P:Marten.Events.Event`1.StreamId">
            <summary>
                A reference to the stream that contains
                this event
            </summary>
        </member>
        <member name="P:Marten.Events.Event`1.StreamKey">
            <summary>
                A reference to the stream if the stream
                identifier mode is AsString
            </summary>
        </member>
        <member name="P:Marten.Events.Event`1.Id">
            <summary>
                An alternative Guid identifier to identify
                events across databases
            </summary>
        </member>
        <member name="P:Marten.Events.Event`1.Version">
            <summary>
                An event's version position within its event stream
            </summary>
        </member>
        <member name="P:Marten.Events.Event`1.Sequence">
            <summary>
                A global sequential number identifying the Event
            </summary>
        </member>
        <member name="P:Marten.Events.Event`1.Timestamp">
            <summary>
                The UTC time that this event was originally captured
            </summary>
        </member>
        <member name="P:Marten.Events.Event`1.CausationId">
            <summary>
            Optional metadata describing the causation id
            </summary>
        </member>
        <member name="P:Marten.Events.Event`1.CorrelationId">
            <summary>
            Optional metadata describing the correlation id
            </summary>
        </member>
        <member name="P:Marten.Events.Event`1.Headers">
            <summary>
            This is meant to be lazy created, and can be null
            </summary>
        </member>
        <member name="T:Marten.Events.EventDocumentStorage">
            <summary>
            Base type for the IEventStorage type that provides all the read/write operation
            mapping for the event store in a running system. The actual implementation of this
            base type is generated and compiled at runtime by Marten
            </summary>
        </member>
        <member name="P:Marten.Events.EventGraph.UseAppendEventForUpdateLock">
            <summary>
                Whether a "for update" (row exclusive lock) should be used when selecting out the event version to use from the
                streams table
            </summary>
            <remarks>
                Not using this can result in race conditions in a concurrent environment that lead to
                event version mismatches between the event and stream version numbers
            </remarks>
        </member>
        <member name="P:Marten.Events.EventGraph.StreamIdentity">
            <summary>
                Configure whether event streams are identified with Guid or strings
            </summary>
        </member>
        <member name="P:Marten.Events.EventGraph.TenancyStyle">
            <summary>
                Configure the event sourcing storage for multi-tenancy
            </summary>
        </member>
        <member name="P:Marten.Events.EventGraph.MetadataConfig">
            <summary>
                Configure the meta data required to be stored for events. By default meta data fields are disabled
            </summary>
        </member>
        <member name="M:Marten.Events.EventGraph.AddEventType(System.Type)">
            <summary>
                Register an event type with Marten. This isn't strictly necessary for normal usage,
                but can help Marten with asynchronous projections where Marten hasn't yet encountered
                the event type
            </summary>
            <param name="eventType"></param>
        </member>
        <member name="M:Marten.Events.EventGraph.AddEventTypes(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
                Register an event type with Marten. This isn't strictly necessary for normal usage,
                but can help Marten with asynchronous projections where Marten hasn't yet encountered
                the event type
            </summary>
            <param name="types"></param>
        </member>
        <member name="P:Marten.Events.EventGraph.DatabaseSchemaName">
            <summary>
                Override the database schema name for event related tables. By default this
                is the same schema as the document storage
            </summary>
        </member>
        <member name="T:Marten.Events.EventSequenceFetcher">
            <summary>
            Used to fetch the next N values of the event store sequence numbers
            </summary>
        </member>
        <member name="M:Marten.Events.EventStoreExtensions.AggregateTo``1(Marten.Linq.IMartenQueryable{Marten.Events.IEvent},``0)">
            <summary>
            Aggregate the events in this query to the type T
            </summary>
            <param name="queryable"></param>
            <param name="state"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.EventStoreExtensions.AggregateToAsync``1(Marten.Linq.IMartenQueryable{Marten.Events.IEvent},``0,System.Threading.CancellationToken)">
            <summary>
            Aggregate the events in this query to the type T
            </summary>
            <param name="queryable"></param>
            <param name="state"></param>
            <param name="token"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="P:Marten.Events.EventStoreStatistics.EventCount">
            <summary>
            Number of unique events in the event store table
            </summary>
        </member>
        <member name="P:Marten.Events.EventStoreStatistics.StreamCount">
            <summary>
            Number of unique streams in the event store
            </summary>
        </member>
        <member name="P:Marten.Events.EventStoreStatistics.EventSequenceNumber">
            <summary>
            Current value of the event sequence. This may be higher than the number
            of events if events have been archived or if there were failures while
            appending events
            </summary>
        </member>
        <member name="T:Marten.Events.IEventStorage">
            <summary>
            The implementation of this class is generated at runtime based on the configuration
            of the system
            </summary>
        </member>
        <member name="M:Marten.Events.IEventStorage.AppendEvent(Marten.Events.EventGraph,Marten.Internal.IMartenSession,Marten.Events.StreamAction,Marten.Events.IEvent)">
            <summary>
            Create a storage operation to append a single event
            </summary>
            <param name="events"></param>
            <param name="session"></param>
            <param name="stream"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStorage.InsertStream(Marten.Events.StreamAction)">
            <summary>
            Create a storage operation to insert a single event stream record
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStorage.QueryForStream(Marten.Events.StreamAction)">
            <summary>
            Create an IQueryHandler to find and load a Stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStorage.UpdateStreamVersion(Marten.Events.StreamAction)">
            <summary>
            Create a storage operation for updating the version of a single stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.Append(System.Guid,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Append one or more events in order to an existing stream
            </summary>
            <param name="stream"></param>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.IEventOperations.Append(System.Guid,System.Object[])">
            <summary>
            Append one or more events in order to an existing stream
            </summary>
            <param name="stream"></param>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.IEventOperations.Append(System.String,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Append one or more events in order to an existing stream
            </summary>
            <param name="stream"></param>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.IEventOperations.Append(System.String,System.Object[])">
            <summary>
            Append one or more events in order to an existing stream
            </summary>
            <param name="stream"></param>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.IEventOperations.Append(System.Guid,System.Int64,System.Object[])">
            <summary>
            Append one or more events in order to an existing stream and verify that maximum event id for the stream
            matches supplied expected version or transaction is aborted.
            </summary>
            <param name="stream"></param>
            <param name="expectedVersion">Expected maximum event version after append</param>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.IEventOperations.Append(System.String,System.Int64,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Append one or more events in order to an existing stream and verify that maximum event id for the stream
            matches supplied expected version or transaction is aborted.
            </summary>
            <param name="stream"></param>
            <param name="expectedVersion">Expected maximum event version after append</param>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.IEventOperations.Append(System.String,System.Int64,System.Object[])">
            <summary>
            Append one or more events in order to an existing stream and verify that maximum event id for the stream
            matches supplied expected version or transaction is aborted.
            </summary>
            <param name="stream"></param>
            <param name="expectedVersion">Expected maximum event version after append</param>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream``1(System.Guid,System.Object[])">
            <summary>
            Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="id"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream(System.Type,System.Guid,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
            </summary>
            <param name="aggregateType"></param>
            <param name="id"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream(System.Type,System.Guid,System.Object[])">
            <summary>
            Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
            </summary>
            <param name="aggregateType"></param>
            <param name="id"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream``1(System.String,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
             - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="streamKey">String identifier of this stream</param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream``1(System.String,System.Object[])">
            <summary>
            Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
             - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="streamKey">String identifier of this stream</param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream(System.Type,System.String,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
             - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <param name="aggregateType"></param>
            <param name="streamKey">String identifier of this stream</param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream(System.Type,System.String,System.Object[])">
            <summary>
            Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
             - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <param name="aggregateType"></param>
            <param name="streamKey">String identifier of this stream</param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream(System.Guid,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <param name="id"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream(System.Guid,System.Object[])">
            <summary>
            Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <param name="id"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream(System.String,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
             - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <param name="streamKey"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream(System.String,System.Object[])">
            <summary>
            Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
             - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <param name="streamKey"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream``1(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Creates a new event stream, assigns a new Guid id, and appends the events in order to the new stream
             - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream``1(System.Object[])">
            <summary>
            Creates a new event stream, assigns a new Guid id, and appends the events in order to the new stream
             - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream(System.Type,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Creates a new event stream, assigns a new Guid id, and appends the events in order to the new stream
             - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream(System.Type,System.Object[])">
            <summary>
            Creates a new event stream, assigns a new Guid id, and appends the events in order to the new stream
             - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Creates a new event stream, assigns a new Guid id, and appends the events in order to the new stream
             - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream(System.Object[])">
            <summary>
            Creates a new event stream, assigns a new Guid id, and appends the events in order to the new stream
             - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.Append(System.Guid,System.Int64,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Append one or more events in order to an existing stream and verify that maximum event id for the stream
            matches supplied expected version or transaction is aborted.
            </summary>
            <param name="stream"></param>
            <param name="expectedVersion">Expected maximum event version after append</param>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.IEventStore.StartStream``1(System.Guid,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="id"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.AppendOptimistic(System.String,System.Threading.CancellationToken,System.Object[])">
            <summary>
            Append events to an existing stream with optimistic concurrency checks against the
            existing version of the stream
            </summary>
            <param name="streamKey"></param>
            <param name="token"></param>
            <param name="events"></param>
            <exception cref="!:NonExistentStreamException"></exception>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.AppendOptimistic(System.String,System.Object[])">
            <summary>
            Append events to an existing stream with optimistic concurrency checks against the
            existing version of the stream
            </summary>
            <param name="streamKey"></param>
            <param name="events"></param>
            <exception cref="!:NonExistentStreamException"></exception>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.AppendOptimistic(System.Guid,System.Threading.CancellationToken,System.Object[])">
            <summary>
            Append events to an existing stream with optimistic concurrency checks against the
            existing version of the stream
            </summary>
            <param name="streamId"></param>
            <param name="token"></param>
            <param name="events"></param>
            <exception cref="!:NonExistentStreamException"></exception>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.AppendOptimistic(System.Guid,System.Object[])">
            <summary>
            Append events to an existing stream with optimistic concurrency checks against the
            existing version of the stream
            </summary>
            <param name="streamId"></param>
            <param name="events"></param>
            <exception cref="!:NonExistentStreamException"></exception>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.AppendExclusive(System.String,System.Threading.CancellationToken,System.Object[])">
            <summary>
            Append events to an existing stream with an exclusive lock against the
            stream until this session is saved
            </summary>
            <param name="streamKey"></param>
            <param name="token"></param>
            <param name="events"></param>
            <exception cref="!:NonExistentStreamException"></exception>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.AppendExclusive(System.String,System.Object[])">
            <summary>
            Append events to an existing stream with an exclusive lock against the
            stream until this session is saved
            </summary>
            <param name="streamKey"></param>
            <param name="events"></param>
            <exception cref="!:NonExistentStreamException"></exception>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.AppendExclusive(System.Guid,System.Threading.CancellationToken,System.Object[])">
            <summary>
            Append events to an existing stream with an exclusive lock against the
            stream until this session is saved
            </summary>
            <param name="streamId"></param>
            <param name="events"></param>
            <exception cref="!:NonExistentStreamException"></exception>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.AppendExclusive(System.Guid,System.Object[])">
            <summary>
            Append events to an existing stream with an exclusive lock against the
            stream until this session is saved
            </summary>
            <param name="streamId"></param>
            <param name="events"></param>
            <exception cref="!:NonExistentStreamException"></exception>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.ArchiveStream(System.Guid)">
            <summary>
            Mark a stream and all its events as archived
            </summary>
            <param name="streamId"></param>
        </member>
        <member name="M:Marten.Events.IEventStore.ArchiveStream(System.String)">
            <summary>
            Mark a stream and all its events as archived
            </summary>
            <param name="streamKey"></param>
        </member>
        <member name="P:Marten.Events.IEventStoreOptions.StreamIdentity">
            <summary>
            Configure whether event streams are identified with Guid or strings
            </summary>
        </member>
        <member name="P:Marten.Events.IEventStoreOptions.TenancyStyle">
            <summary>
            Configure the event sourcing storage for multi-tenancy
            </summary>
        </member>
        <member name="P:Marten.Events.IEventStoreOptions.DatabaseSchemaName">
            <summary>
            Override the database schema name for event related tables. By default this
            is the same schema as the document storage
            </summary>
        </member>
        <member name="M:Marten.Events.IEventStoreOptions.AddEventType(System.Type)">
            <summary>
            Register an event type with Marten. This isn't strictly necessary for normal usage,
            but can help Marten with asynchronous projections where Marten hasn't yet encountered
            the event type
            </summary>
            <param name="eventType"></param>
        </member>
        <member name="M:Marten.Events.IEventStoreOptions.AddEventTypes(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Register an event type with Marten. This isn't strictly necessary for normal usage,
            but can help Marten with asynchronous projections where Marten hasn't yet encountered
            the event type
            </summary>
            <param name="types"></param>
        </member>
        <member name="M:Marten.Events.IEventStoreOptions.MapEventType``1(System.String)">
            <summary>
            Maps CLR event type as particular event type name. This is useful for event type migration.
            See more in docs: https://martendb.io/events/versioning.html#event-type-name-migration
            </summary>
            <param name="eventTypeName">Event type name</param>
            <typeparam name="TEvent">Mapped CLR event type</typeparam>
        </member>
        <member name="M:Marten.Events.IEventStoreOptions.MapEventType(System.Type,System.String)">
            <summary>
            Maps CLR event type as particular event type name. This is useful for event type migration.
            See more in docs: https://martendb.io/events/versioning.html#event-type-name-migration
            </summary>
            <param name="eventType">Event type name</param>
            <param name="eventTypeName">Mapped CLR event type</param>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.FetchStream(System.Guid,System.Int64,System.Nullable{System.DateTime},System.Int64)">
            <summary>
            Synchronously fetches all of the events for the named stream
            </summary>
            <param name="streamId"></param>
            <param name="version">If set, queries for events up to and including this version</param>
            <param name="timestamp">If set, queries for events captured on or before this timestamp</param>
            <param name="fromVersion">If set, queries for events on or from this version</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.FetchStreamAsync(System.Guid,System.Int64,System.Nullable{System.DateTime},System.Int64,System.Threading.CancellationToken)">
            <summary>
            Synchronously fetches all of the events for the named stream
            </summary>
            <param name="streamId"></param>
            <param name="version">If set, queries for events up to and including this version</param>
            <param name="timestamp">If set, queries for events captured on or before this timestamp</param>
            <param name="fromVersion">If set, queries for events on or from this version</param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.FetchStream(System.String,System.Int64,System.Nullable{System.DateTime},System.Int64)">
            <summary>
            Synchronously fetches all of the events for the named stream
            </summary>
            <param name="streamKey"></param>
            <param name="version">If set, queries for events up to and including this version</param>
            <param name="timestamp">If set, queries for events captured on or before this timestamp</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.FetchStreamAsync(System.String,System.Int64,System.Nullable{System.DateTime},System.Int64,System.Threading.CancellationToken)">
            <summary>
            Synchronously fetches all of the events for the named stream
            </summary>
            <param name="streamKey"></param>
            <param name="version">If set, queries for events up to and including this version</param>
            <param name="timestamp">If set, queries for events captured on or before this timestamp</param>
            <param name="fromVersion">If set, queries for events on or from this version</param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.AggregateStream``1(System.Guid,System.Int64,System.Nullable{System.DateTime},``0,System.Int64)">
            <summary>
            Perform a live aggregation of the raw events in this stream to a T object
            </summary>
            <typeparam name="T"></typeparam>
            <param name="streamId"></param>
            <param name="version">If set, queries for events up to and including this version</param>
            <param name="timestamp">If set, queries for events captured on or before this timestamp</param>
            <param name="fromVersion">If set, queries for events on or from this version</param>
            <param name="state">Instance of T to apply events to</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.AggregateStreamAsync``1(System.Guid,System.Int64,System.Nullable{System.DateTime},``0,System.Int64,System.Threading.CancellationToken)">
            <summary>
            Perform a live aggregation of the raw events in this stream to a T object
            </summary>
            <typeparam name="T"></typeparam>
            <param name="streamId"></param>
            <param name="version">If set, queries for events up to and including this version</param>
            <param name="timestamp">If set, queries for events captured on or before this timestamp</param>
            <param name="fromVersion">If set, queries for events on or from this version</param>
            <param name="state">Instance of T to apply events to</param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.AggregateStream``1(System.String,System.Int64,System.Nullable{System.DateTime},``0,System.Int64)">
            <summary>
            Perform a live aggregation of the raw events in this stream to a T object
            </summary>
            <typeparam name="T"></typeparam>
            <param name="streamKey"></param>
            <param name="version"></param>
            <param name="timestamp"></param>
            <param name="state">Instance of T to apply events to</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.AggregateStreamAsync``1(System.String,System.Int64,System.Nullable{System.DateTime},``0,System.Int64,System.Threading.CancellationToken)">
            <summary>
            Perform a live aggregation of the raw events in this stream to a T object
            </summary>
            <typeparam name="T"></typeparam>
            <param name="streamKey"></param>
            <param name="version">If set, queries for events up to and including this version</param>
            <param name="timestamp">If set, queries for events captured on or before this timestamp</param>
            <param name="fromVersion">If set, queries for events on or from this version</param>
            <param name="state">Instance of T to apply events to</param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.QueryRawEventDataOnly``1">
            <summary>
            Query directly against ONLY the raw event data. Use IQuerySession.Query() for aggregated documents!
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.QueryAllRawEvents">
            <summary>
            Query directly against the raw event data across all event types
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.Load``1(System.Guid)">
            <summary>
            Load a single event by its id knowing the event type upfront
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.LoadAsync``1(System.Guid,System.Threading.CancellationToken)">
            <summary>
            Load a single event by its id knowing the event type upfront
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.Load(System.Guid)">
            <summary>
            Load a single event by its id
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.LoadAsync(System.Guid,System.Threading.CancellationToken)">
            <summary>
            Load a single event by its id
            </summary>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.FetchStreamState(System.Guid)">
            <summary>
            Fetches only the metadata about a stream by id
            </summary>
            <param name="streamId"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.FetchStreamStateAsync(System.Guid,System.Threading.CancellationToken)">
            <summary>
            Fetches only the metadata about a stream by id
            </summary>
            <param name="streamId"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.FetchStreamState(System.String)">
            <summary>
            Fetches only the metadata about a stream by id
            </summary>
            <param name="streamKey"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.FetchStreamStateAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Fetches only the metadata about a stream by id
            </summary>
            <param name="streamKey"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.Events.IReadOnlyEventStoreOptions.Daemon">
            <summary>
            Advanced configuration for the asynchronous projection execution
            </summary>
        </member>
        <member name="P:Marten.Events.IReadOnlyEventStoreOptions.StreamIdentity">
            <summary>
            Configure whether event streams are identified with Guid or strings
            </summary>
        </member>
        <member name="P:Marten.Events.IReadOnlyEventStoreOptions.TenancyStyle">
            <summary>
            Configure the event sourcing storage for multi-tenancy
            </summary>
        </member>
        <member name="P:Marten.Events.IReadOnlyEventStoreOptions.DatabaseSchemaName">
            <summary>
            Override the database schema name for event related tables. By default this
            is the same schema as the document storage
            </summary>
        </member>
        <member name="M:Marten.Events.IReadOnlyEventStoreOptions.Projections">
            <summary>
            Configuration for all event store projections
            </summary>
        </member>
        <member name="P:Marten.Events.IReadOnlyEventStoreOptions.MetadataConfig">
            <summary>
            Metadata configuration
            </summary>
        </member>
        <member name="P:Marten.Events.IReadonlyMetadataConfig.CorrelationIdEnabled">
            <summary>
            Optional metadata describing the correlation id for an events
            </summary>
        </member>
        <member name="P:Marten.Events.IReadonlyMetadataConfig.CausationIdEnabled">
            <summary>
            Optional metadata describing the causation id for an events
            </summary>
        </member>
        <member name="P:Marten.Events.IReadonlyMetadataConfig.HeadersEnabled">
            <summary>
            Optional, user defined headers for an event
            </summary>
        </member>
        <member name="P:Marten.Events.MetadataConfig.CorrelationIdEnabled">
            <summary>
            Setting to enable optional correlation id metadata for events
            </summary>
        </member>
        <member name="P:Marten.Events.MetadataConfig.CausationIdEnabled">
            <summary>
            Setting to enable optional causation id metadata for events
            </summary>
        </member>
        <member name="P:Marten.Events.MetadataConfig.HeadersEnabled">
            <summary>
            Setting to enable optional user defined metadata for events
            </summary>
        </member>
        <member name="M:Marten.Events.MetadataConfig.EnableAll">
            <summary>
            Method to enable all optional metadata fields
            </summary>
        </member>
        <member name="T:Marten.Events.Querying.StreamStateQueryHandler">
            <summary>
            Internal base class for generated stream state query handling
            </summary>
        </member>
        <member name="T:Marten.Events.Schema.IEventTableColumn">
            <summary>
            This interface is used by the event store code generation to build the IEventStorage
            </summary>
        </member>
        <member name="M:Marten.Events.Schema.IEventTableColumn.GenerateSelectorCodeSync(LamarCodeGeneration.GeneratedMethod,Marten.Events.EventGraph,System.Int32)">
            <summary>
            Generate the synchronous IEventSelector code for this event table column
            </summary>
            <param name="method"></param>
            <param name="graph"></param>
            <param name="index"></param>
        </member>
        <member name="M:Marten.Events.Schema.IEventTableColumn.GenerateSelectorCodeAsync(LamarCodeGeneration.GeneratedMethod,Marten.Events.EventGraph,System.Int32)">
            <summary>
            Generate the asynchronous IEventSelector code for this event table column
            </summary>
            <param name="method"></param>
            <param name="graph"></param>
            <param name="index"></param>
        </member>
        <member name="M:Marten.Events.Schema.IEventTableColumn.GenerateAppendCode(LamarCodeGeneration.GeneratedMethod,Marten.Events.EventGraph,System.Int32)">
            <summary>
            Generate code for this column to capture the NpgsqlParameter value that should
            be persisted when appending an event to the events table
            </summary>
            <param name="method"></param>
            <param name="graph"></param>
            <param name="index"></param>
        </member>
        <member name="P:Marten.Events.Schema.IEventTableColumn.Name">
            <summary>
            Column name
            </summary>
        </member>
        <member name="F:Marten.Events.StreamActionType.Start">
            <summary>
            This is a new stream. This action will be rejected
            if a stream with the same identity exists in the database
            </summary>
        </member>
        <member name="F:Marten.Events.StreamActionType.Append">
            <summary>
            Append these events to an existing stream. If the stream does not
            already exist, it will be created with these events
            </summary>
        </member>
        <member name="T:Marten.Events.StreamAction">
            <summary>
            Models a series of events to be appended to either a new or
            existing stream
            </summary>
        </member>
        <member name="P:Marten.Events.StreamAction.Id">
            <summary>
            Identity of the stream if using Guid's as the identity
            </summary>
        </member>
        <member name="P:Marten.Events.StreamAction.Key">
            <summary>
            The identity of this stream if using strings as the stream
            identity
            </summary>
        </member>
        <member name="P:Marten.Events.StreamAction.ActionType">
            <summary>
            Is this action the start of a new stream or appending
            to an existing stream?
            </summary>
        </member>
        <member name="P:Marten.Events.StreamAction.AggregateType">
            <summary>
            If the stream was started as tagged to an aggregate type, that will
            be reflected in this property. May be null
            </summary>
        </member>
        <member name="P:Marten.Events.StreamAction.AggregateTypeName">
            <summary>
            Marten's name for the aggregate type that will be persisted
            to the streams table
            </summary>
        </member>
        <member name="P:Marten.Events.StreamAction.TenantId">
            <summary>
            The Id of the current tenant
            </summary>
        </member>
        <member name="P:Marten.Events.StreamAction.Events">
            <summary>
            The events involved in this action
            </summary>
        </member>
        <member name="P:Marten.Events.StreamAction.ExpectedVersionOnServer">
            <summary>
            The expected starting version of the stream in the server. This is used
            to facilitate optimistic concurrency checks
            </summary>
        </member>
        <member name="P:Marten.Events.StreamAction.Version">
            <summary>
            The ending version of the stream for this action
            </summary>
        </member>
        <member name="P:Marten.Events.StreamAction.Timestamp">
            <summary>
            The recorded timestamp for these events
            </summary>
        </member>
        <member name="P:Marten.Events.StreamAction.Created">
            <summary>
            When was the stream created
            </summary>
        </member>
        <member name="M:Marten.Events.StreamAction.Start(Marten.Events.EventGraph,System.Guid,System.Object[])">
            <summary>
            Create a new StreamAction for starting a new stream
            </summary>
            <param name="streamId"></param>
            <param name="events"></param>
            <returns></returns>
            <exception cref="T:Marten.Exceptions.EmptyEventStreamException"></exception>
        </member>
        <member name="M:Marten.Events.StreamAction.Start(System.Guid,Marten.Events.IEvent[])">
            <summary>
            Create a new StreamAction for starting a new stream
            </summary>
            <param name="streamId"></param>
            <param name="events"></param>
            <returns></returns>
            <exception cref="T:Marten.Exceptions.EmptyEventStreamException"></exception>
        </member>
        <member name="M:Marten.Events.StreamAction.Start(Marten.Events.EventGraph,System.String,System.Object[])">
            <summary>
            Create a new StreamAction for starting a new stream
            </summary>
            <param name="streamKey"></param>
            <param name="events"></param>
            <returns></returns>
            <exception cref="T:Marten.Exceptions.EmptyEventStreamException"></exception>
        </member>
        <member name="M:Marten.Events.StreamAction.Start(System.String,Marten.Events.IEvent[])">
            <summary>
            Create a new StreamAction for starting a new stream
            </summary>
            <param name="streamKey"></param>
            <param name="events"></param>
            <returns></returns>
            <exception cref="T:Marten.Exceptions.EmptyEventStreamException"></exception>
        </member>
        <member name="M:Marten.Events.StreamAction.Append(Marten.Events.EventGraph,System.Guid,System.Object[])">
            <summary>
            Create a new StreamAction for appending to an existing stream
            </summary>
            <param name="streamId"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.StreamAction.Append(System.Guid,Marten.Events.IEvent[])">
            <summary>
            Create a new StreamAction for appending to an existing stream
            </summary>
            <param name="streamId"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.StreamAction.Append(Marten.Events.EventGraph,System.String,System.Object[])">
            <summary>
            Create a new StreamAction for appending to an existing stream
            </summary>
            <param name="streamKey"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.StreamAction.Append(System.String,Marten.Events.IEvent[])">
            <summary>
            Create a new StreamAction for appending to an existing stream
            </summary>
            <param name="streamKey"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.StreamAction.PrepareEvents(System.Int64,Marten.Events.EventGraph,System.Collections.Generic.Queue{System.Int64},Marten.Internal.IMartenSession)">
            <summary>
            Applies versions, .Net type aliases, the reserved sequence numbers, timestamps, etc.
            to get the events ready to be inserted into the mt_events table
            </summary>
            <param name="currentVersion"></param>
            <param name="graph"></param>
            <param name="sequences"></param>
            <param name="session"></param>
            <exception cref="T:Marten.Exceptions.EventStreamUnexpectedMaxEventIdException"></exception>
        </member>
        <member name="T:Marten.Events.StreamIdentity">
            <summary>
            Specify the identity strategy for event streams
            </summary>
        </member>
        <member name="F:Marten.Events.StreamIdentity.AsGuid">
            <summary>
            Streams should be identified by Guid
            </summary>
        </member>
        <member name="F:Marten.Events.StreamIdentity.AsString">
            <summary>
            Streams should be identified by a user supplied string
            </summary>
        </member>
        <member name="P:Marten.Events.StreamState.Id">
            <summary>
            Identity of the stream if using Guid's as the identity
            </summary>
        </member>
        <member name="P:Marten.Events.StreamState.Version">
            <summary>
            Current version of the stream in the database. Corresponds to
            the number of events in the stream
            </summary>
        </member>
        <member name="P:Marten.Events.StreamState.AggregateType">
            <summary>
            If the stream was started as tagged to an aggregate type, that will
            be reflected in this property. May be null
            </summary>
        </member>
        <member name="P:Marten.Events.StreamState.LastTimestamp">
            <summary>
            The last time this stream was appended to
            </summary>
        </member>
        <member name="P:Marten.Events.StreamState.Created">
            <summary>
            The time at which this stream was created
            </summary>
        </member>
        <member name="P:Marten.Events.StreamState.Key">
            <summary>
            The identity of this stream if using strings as the stream
            identity
            </summary>
        </member>
        <member name="P:Marten.Events.StreamState.IsArchived">
            <summary>
            Is this event stream marked as archived
            </summary>
        </member>
        <member name="M:Marten.Events.TestSupport.ProjectionScenario.AssertAgainstProjectedData(System.String,System.Func{Marten.IQuerySession,System.Threading.Tasks.Task})">
            <summary>
            General hook to run
            </summary>
            <param name="description"></param>
            <param name="assertions"></param>
        </member>
        <member name="M:Marten.Events.TestSupport.ProjectionScenario.DocumentShouldExist``1(System.String,System.Action{``0})">
            <summary>
                Verify that a document with the supplied id exists
            </summary>
            <param name="id"></param>
            <param name="assertions">Optional lambda to make additional assertions about the document state</param>
            <typeparam name="T">The document type</typeparam>
        </member>
        <member name="M:Marten.Events.TestSupport.ProjectionScenario.DocumentShouldExist``1(System.Int64,System.Action{``0})">
            <summary>
                Verify that a document with the supplied id exists
            </summary>
            <param name="id"></param>
            <param name="assertions">Optional lambda to make additional assertions about the document state</param>
            <typeparam name="T">The document type</typeparam>
        </member>
        <member name="M:Marten.Events.TestSupport.ProjectionScenario.DocumentShouldExist``1(System.Int32,System.Action{``0})">
            <summary>
                Verify that a document with the supplied id exists
            </summary>
            <param name="id"></param>
            <param name="assertions">Optional lambda to make additional assertions about the document state</param>
            <typeparam name="T">The document type</typeparam>
        </member>
        <member name="M:Marten.Events.TestSupport.ProjectionScenario.DocumentShouldExist``1(System.Guid,System.Action{``0})">
            <summary>
                Verify that a document with the supplied id exists
            </summary>
            <param name="id"></param>
            <param name="assertions">Optional lambda to make additional assertions about the document state</param>
            <typeparam name="T">The document type</typeparam>
        </member>
        <member name="M:Marten.Events.TestSupport.ProjectionScenario.DocumentShouldNotExist``1(System.String)">
            <summary>
                Asserts that a document with a given id has been deleted or does not exist
            </summary>
            <param name="id">The identity of the document</param>
            <typeparam name="T">The document type</typeparam>
        </member>
        <member name="M:Marten.Events.TestSupport.ProjectionScenario.DocumentShouldNotExist``1(System.Int64)">
            <summary>
                Asserts that a document with a given id has been deleted or does not exist
            </summary>
            <param name="id">The identity of the document</param>
            <typeparam name="T">The document type</typeparam>
        </member>
        <member name="M:Marten.Events.TestSupport.ProjectionScenario.DocumentShouldNotExist``1(System.Int32)">
            <summary>
                Asserts that a document with a given id has been deleted or does not exist
            </summary>
            <param name="id">The identity of the document</param>
            <typeparam name="T">The document type</typeparam>
        </member>
        <member name="M:Marten.Events.TestSupport.ProjectionScenario.DocumentShouldNotExist``1(System.Guid)">
            <summary>
                Asserts that a document with a given id has been deleted or does not exist
            </summary>
            <param name="id">The identity of the document</param>
            <typeparam name="T">The document type</typeparam>
        </member>
        <member name="P:Marten.Events.TestSupport.ProjectionScenario.DoNotDeleteExistingData">
            <summary>
                Disable the scenario from "cleaning" out any existing
                event and projected document data before running the scenario
            </summary>
        </member>
        <member name="M:Marten.Events.TestSupport.ProjectionScenario.AppendEvents(System.String,System.Action{Marten.Events.IEventOperations})">
            <summary>
            Make any number of append event operations in the scenario sequence
            </summary>
            <param name="description">Descriptive explanation of the action in case of failures</param>
            <param name="appendAction"></param>
        </member>
        <member name="M:Marten.Events.TestSupport.ProjectionScenario.AppendEvents(System.Action{Marten.Events.IEventOperations})">
            <summary>
            Make any number of append event operations in the scenario sequence
            </summary>
            <param name="appendAction"></param>
        </member>
        <member name="T:Marten.Events.TestSupport.ProjectionScenarioException">
            <summary>
                Thrown when a ProjectionScenario fails
            </summary>
        </member>
        <member name="T:Marten.Exceptions.InvalidProjectionException">
            <summary>
            Thrown when any configuration rules for an active projection are violated and the projection is invalid
            </summary>
        </member>
        <member name="T:Marten.Exceptions.MartenCommandException">
            <summary>
            Wraps the Postgres command exceptions. Unifies exception handling and brings additonal information.
            </summary>
        </member>
        <member name="P:Marten.Exceptions.MartenCommandException.Command">
            <summary>
            Failed Postgres command
            </summary>
        </member>
        <member name="M:Marten.Exceptions.MartenCommandException.#ctor(Npgsql.NpgsqlCommand,System.Exception)">
            <summary>
            Creates MartenCommandException based on the command and innerException information with formatted message.
            </summary>
            <param name="command">failed Postgres command</param>
            <param name="innerException">internal exception details</param>
        </member>
        <member name="M:Marten.Exceptions.MartenCommandException.#ctor(Npgsql.NpgsqlCommand,System.Exception,System.String)">
            <summary>
            Creates MartenCommandException based on the command and innerException information with formatted message.
            </summary>
            <param name="command">failed Postgres command</param>
            <param name="innerException">internal exception details</param>
            <param name="prefix">prefix that will be added to message</param>
        </member>
        <member name="T:Marten.Exceptions.MartenCommandExceptionFactory">
            <summary>
            Class responsible for creating MartenCommandException exception or exceptions derived from it based on exact command code.
            </summary>
        </member>
        <member name="T:Marten.Exceptions.NotSupportedReason">
            <summary>
            Reasons for feature not being supported
            </summary>
        </member>
        <member name="F:Marten.Exceptions.NotSupportedReason.FullTextSearchNeedsAtLeastPostgresVersion10">
            <summary>
            Full Text Search needs at least Postgres version 10 - eg. doing PlainTextSearch or using to_tsvector
            </summary>
        </member>
        <member name="F:Marten.Exceptions.NotSupportedReason.WebStyleSearchNeedsAtLeastPostgresVersion11">
            <summary>
            Web Styles Search needs at least Postgres version 11
            </summary>
        </member>
        <member name="T:Marten.Exceptions.MartenCommandNotSupportedException">
            <summary>
            Informs that feature used in Postgres command is not supported
            </summary>
        </member>
        <member name="P:Marten.Exceptions.MartenCommandNotSupportedException.Reason">
            <summary>
            Reason for feature not being supported
            </summary>
        </member>
        <member name="M:Marten.Exceptions.MartenCommandNotSupportedException.#ctor(Marten.Exceptions.NotSupportedReason,Npgsql.NpgsqlCommand,System.Exception,System.String)">
             <summary>
            
             Creates MartenCommandNotSupportedException based on the reason, command and innerException information with formatted message.
             </summary>
             <param name="reason">reason for feature not being supported</param>
             <param name="command">failed Postgres command</param>
             <param name="innerException">internal exception details</param>
             <param name="message">optional additional exception information</param>
        </member>
        <member name="P:Marten.Schema.FullTextIndexAttribute.IndexName">
            <summary>
            Specify the name of the index explicity
            </summary>
        </member>
        <member name="F:Marten.Schema.FullTextIndexAttribute.RegConfig">
            <summary>
            Specify Index type
            </summary>
        </member>
        <member name="T:Marten.Schema.BulkLoading.IBulkLoader`1">
            <summary>
            Internal service to implement bulk loading
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Marten.Schema.ComputedIndex.Casing">
            <summary>
            Marks the column value as upper/lower casing
            </summary>
        </member>
        <member name="P:Marten.Schema.ComputedIndex.TenancyScope">
            <summary>
            Specifies the unique index is scoped to the tenant
            </summary>
        </member>
        <member name="F:Marten.Schema.ComputedIndex.Casings.Default">
            <summary>
            Leave the casing as is (default)
            </summary>
        </member>
        <member name="F:Marten.Schema.ComputedIndex.Casings.Upper">
            <summary>
            Change the casing to uppercase
            </summary>
        </member>
        <member name="F:Marten.Schema.ComputedIndex.Casings.Lower">
            <summary>
            Change the casing to lowercase
            </summary>
        </member>
        <member name="T:Marten.Schema.DatabaseSchemaNameAttribute">
            <summary>
            Overrides the database schema name for the document type
            </summary>
        </member>
        <member name="T:Marten.Schema.DdlTemplateAttribute">
            <summary>
            Override the DDL template for a single document type
            </summary>
        </member>
        <member name="T:Marten.Schema.DocumentAliasAttribute">
            <summary>
            Used to alter the document type alias with Marten to
            avoid naming collisions in the underlying Postgresql
            schema from similarly named document
            types
            </summary>
        </member>
        <member name="M:Marten.Schema.DocumentMapping.ReferencedTypes">
            <summary>
            Access to all other document types that are linked to by foreign keys
            from this document type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Schema.DocumentMapping.AddFullTextIndex(System.String,System.Action{Marten.Schema.FullTextIndex})">
            <summary>
                Adds a full text index
            </summary>
            <param name="regConfig">The dictionary to used by the 'to_tsvector' function, defaults to 'english'.</param>
            <param name="configure">Optional action to further configure the full text index</param>
            <remarks>
                See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-DOCUMENTS
            </remarks>
        </member>
        <member name="M:Marten.Schema.DocumentMapping.AddFullTextIndex(System.Reflection.MemberInfo[][],System.String,System.String)">
            <summary>
                Adds a full text index
            </summary>
            <param name="members">Document fields that should be use by full text index</param>
            <param name="regConfig">The dictionary to used by the 'to_tsvector' function, defaults to 'english'.</param>
            <remarks>
                See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-DOCUMENTS
            </remarks>
        </member>
        <member name="M:Marten.Schema.DocumentMapping`1.FieldFor(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
                Find a field by lambda expression representing a property or field
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Schema.DocumentMapping`1.Duplicate(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String,System.Nullable{NpgsqlTypes.NpgsqlDbType},System.Action{Marten.Schema.DocumentIndex},System.Boolean)">
            <summary>
                Marks a property or field on this document type as a searchable field that is also duplicated in the
                database document table
            </summary>
            <param name="expression"></param>
            <param name="pgType">Optional, overrides the Postgresql column type for the duplicated field</param>
            <param name="configure">
                Optional, allows you to customize the Postgresql database index configured for the duplicated
                field
            </param>
            <returns></returns>
        </member>
        <member name="M:Marten.Schema.DocumentMapping`1.Index(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Action{Marten.Schema.ComputedIndex})">
            <summary>
                Adds a computed index
            </summary>
            <param name="expression"></param>
            <param name="configure"></param>
        </member>
        <member name="M:Marten.Schema.DocumentMapping`1.Index(System.Collections.Generic.IReadOnlyCollection{System.Linq.Expressions.Expression{System.Func{`0,System.Object}}},System.Action{Marten.Schema.ComputedIndex})">
            <summary>
                Adds a computed index
            </summary>
            <param name="expressions"></param>
            <param name="configure"></param>
        </member>
        <member name="M:Marten.Schema.DocumentMapping`1.FullTextIndex(System.String,System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
                Adds a full text index
            </summary>
            <param name="regConfig">The dictionary to used by the 'to_tsvector' function, defaults to 'english'.</param>
            <param name="expressions">Document fields that should be use by full text index</param>
            <remarks>
                See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-DOCUMENTS
            </remarks>
        </member>
        <member name="T:Marten.Schema.DuplicateFieldAttribute">
            <summary>
            Mark a single property or field on a document as a duplicated, searchable field
            for optimized searching
            </summary>
        </member>
        <member name="P:Marten.Schema.DuplicateFieldAttribute.PgType">
            <summary>
            Use to override the Postgresql database column type of this searchable field
            </summary>
        </member>
        <member name="P:Marten.Schema.DuplicateFieldAttribute.DbType">
            <summary>
            Use to override the NpgsqlDbType used when querying with a parameter
            against the property
            </summary>
        </member>
        <member name="P:Marten.Schema.DuplicateFieldAttribute.IndexMethod">
            <summary>
            Specifies the type of index to create
            </summary>
        </member>
        <member name="P:Marten.Schema.DuplicateFieldAttribute.IndexName">
            <summary>
            Specify the name of the index explicity
            </summary>
        </member>
        <member name="P:Marten.Schema.DuplicateFieldAttribute.IndexSortOrder">
            <summary>
            Specifies the sort order of the index (only applicable to B-tree indexes)
            </summary>
        </member>
        <member name="T:Marten.Schema.GinIndexedAttribute">
            <summary>
            Adds a gin index to the JSONB data of a document
            </summary>
        </member>
        <member name="T:Marten.Schema.HiloSequenceAttribute">
            <summary>
            Use to customize the Hilo sequence generation for a single document type
            </summary>
        </member>
        <member name="M:Marten.Schema.IDatabaseCreationExpressions.ForTenant(System.String)">
            <param name="tenantId">If omitted, configure for default tenancy</param>
        </member>
        <member name="M:Marten.Schema.IDatabaseCreationExpressions.MaintenanceDatabase(System.String)">
            <summary>
            Setup the maintenance database to which to connect to prior to database creation.
            If not specified, the store connection string with 'postgres' as database is used.
            </summary>
        </member>
        <member name="T:Marten.Schema.Identity.CombGuidIdGeneration">
            <summary>
                Comb Guid Id Generation. More info http://www.informit.com/articles/article.aspx?p=25862
            </summary>
        </member>
        <member name="M:Marten.Schema.Identity.CombGuidIdGeneration.NewGuid(System.DateTimeOffset)">
            <summary>
                Returns a new Guid COMB, consisting of a random Guid combined with the provided timestamp.
            </summary>
        </member>
        <member name="T:Marten.Schema.Identity.GuidIdGeneration">
            <summary>
            Simple Guid identity generation
            </summary>
        </member>
        <member name="T:Marten.Schema.Identity.IIdGeneration">
            <summary>
            Identity generation strategy
            </summary>
        </member>
        <member name="P:Marten.Schema.Identity.IIdGeneration.KeyTypes">
            <summary>
            What types are supported by this strategy? Example: string, or int/long, or Guid
            </summary>
        </member>
        <member name="P:Marten.Schema.Identity.IIdGeneration.RequiresSequences">
            <summary>
            Does this strategy require HiLo sequences
            </summary>
        </member>
        <member name="M:Marten.Schema.Identity.IIdGeneration.GenerateCode(LamarCodeGeneration.GeneratedMethod,Marten.Schema.DocumentMapping)">
            <summary>
            This method must be implemented to build and set the identity on
            a document
            </summary>
            <param name="method"></param>
            <param name="mapping"></param>
        </member>
        <member name="T:Marten.Schema.Identity.NoOpIdGeneration">
            <summary>
            User-assigned identity strategy
            </summary>
        </member>
        <member name="T:Marten.Schema.Identity.StringIdGeneration">
            <summary>
            Validating identity strategy for user supplied string identities
            </summary>
        </member>
        <member name="T:Marten.Schema.IdentityAttribute">
            <summary>
            Use to designate an Id property or field on a document type that doesn't follow the
            id/Id naming convention
            </summary>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteAllDocuments">
            <summary>
            Deletes all existing document data in the underlying Postgresql database
            </summary>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteAllDocumentsAsync">
            <summary>
            Deletes all existing document data in the underlying Postgresql database
            </summary>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteDocumentsByType(System.Type)">
            <summary>
            Deletes all the existing document data for the specified document type
            </summary>
            <param name="documentType"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteDocumentsByTypeAsync(System.Type)">
            <summary>
            Deletes all the existing document data for the specified document type
            </summary>
            <param name="documentType"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteDocumentsExcept(System.Type[])">
            <summary>
            Delete all document data *except* for the specified document types.
            </summary>
            <param name="documentTypes"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteDocumentsExceptAsync(System.Type[])">
            <summary>
            Delete all document data *except* for the specified document types.
            </summary>
            <param name="documentTypes"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.CompletelyRemove(System.Type)">
            <summary>
            Drop all the schema objects in the underlying Postgresql database for the specified
            document type
            </summary>
            <param name="documentType"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.CompletelyRemoveAsync(System.Type)">
            <summary>
            Drop all the schema objects in the underlying Postgresql database for the specified
            document type
            </summary>
            <param name="documentType"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.CompletelyRemoveAll">
            <summary>
            Remove all Marten-related schema objects from the underlying Postgresql database
            </summary>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.CompletelyRemoveAllAsync">
            <summary>
            Remove all Marten-related schema objects from the underlying Postgresql database
            </summary>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteAllEventData">
            <summary>
            Completely deletes all the event and stream data
            </summary>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteAllEventDataAsync">
            <summary>
            Completely deletes all the event and stream data
            </summary>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteSingleEventStream(System.Guid)">
            <summary>
            Deletes all stream and event data for the designated streamId. Will
            not impact projected documents. USE WITH CAUTION!
            </summary>
            <param name="streamId"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteSingleEventStreamAsync(System.Guid)">
            <summary>
            Deletes all stream and event data for the designated streamId. Will
            not impact projected documents. USE WITH CAUTION!
            </summary>
            <param name="streamId"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteSingleEventStream(System.String)">
            <summary>
            Deletes all stream and event data for the designated streamId. Will
            not impact projected documents. USE WITH CAUTION!
            </summary>
            <param name="streamId"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteSingleEventStreamAsync(System.String)">
            <summary>
            Deletes all stream and event data for the designated streamId. Will
            not impact projected documents. USE WITH CAUTION!
            </summary>
            <param name="streamId"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentSchema.WriteDatabaseCreationScriptFile(System.String)">
            <summary>
                Write the SQL script to build the database schema
                objects to a file
            </summary>
            <param name="filename"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentSchema.WriteDatabaseCreationScriptByType(System.String)">
            <summary>
                Write all the SQL scripts to build the database schema, but
                split by document type
            </summary>
            <param name="directory"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentSchema.ToDatabaseScript">
            <summary>
                Creates all the SQL script that would build all the database
                schema objects for the configured schema
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Schema.IDocumentSchema.WriteMigrationFileAsync(System.String)">
            <summary>
                Tries to write a "patch" SQL file to upgrade the database
                to the current Marten schema configuration. Also writes a corresponding
                rollback file as well.
            </summary>
            <param name="filename"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentSchema.CreateMigrationAsync">
            <summary>
                Tries to write a "patch" SQL text to upgrade the database
                to the current Marten schema configuration
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Schema.IDocumentSchema.AssertDatabaseMatchesConfigurationAsync">
            <summary>
                Validates the Marten configuration of documents and transforms against
                the current database schema. Will throw an exception if any differences are
                detected. Useful for "environment tests"
            </summary>
        </member>
        <member name="M:Marten.Schema.IDocumentSchema.ApplyAllConfiguredChangesToDatabaseAsync(System.Nullable{Weasel.Postgresql.AutoCreate})">
            <summary>
                Executes all detected DDL patches to the schema based on current configuration
                upfront at one time
            </summary>
        </member>
        <member name="M:Marten.Schema.IDocumentSchema.CreateMigrationAsync(System.Type)">
            <summary>
                Generate a DDL patch for one specific document type
            </summary>
            <param name="documentType"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Schema.IDocumentSchema.WriteMigrationFileByTypeAsync(System.String)">
            <summary>
            Write a migration file for a single document type to the supplied file name
            </summary>
            <param name="directory"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Schema.IInitialData">
            <summary>
            A set of initial data to pre-populate a DocumentStore at startup time
            Users will have to be responsible for not duplicating data
            </summary>
        </member>
        <member name="M:Marten.Schema.IInitialData.Populate(Marten.IDocumentStore)">
            <summary>
            Apply the data loading
            </summary>
            <param name="store"></param>
        </member>
        <member name="T:Marten.Schema.IndexedLastModifiedAttribute">
            <summary>
            Creates an index on the predefined Last Modified column
            </summary>
        </member>
        <member name="F:Marten.Schema.Indexing.Unique.TenancyScope.Global">
            <summary>
            The uniqueness of this index should be global for all tenants
            </summary>
        </member>
        <member name="F:Marten.Schema.Indexing.Unique.TenancyScope.PerTenant">
            <summary>
            The uniqueness of this index should be within one tenant
            </summary>
        </member>
        <member name="T:Marten.Schema.ITenantDatabaseCreationExpressions">
            <summary>
            Specify options that are passed to CREATE DATABASE.
            <see href="https://www.postgresql.org/docs/current/static/sql-createdatabase.html">CREATE DATABASE</see> documentation for options.
            </summary>
        </member>
        <member name="M:Marten.Schema.ITenantDatabaseCreationExpressions.DropExisting(System.Boolean)">
            <summary>
            If database exists, it is dropped prior to re-creation.
            </summary>
            <param name="killConnections">Kill connections to database prior to drop</param>
            <remarks>Requires CREATEDB privilege</remarks>
        </member>
        <member name="M:Marten.Schema.ITenantDatabaseCreationExpressions.CheckAgainstPgDatabase">
            <summary>
            Check for database existence from pg_database, otherwise detect "INVALID CATALOG NAME" on connect
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Schema.ITenantDatabaseCreationExpressions.OnDatabaseCreated(System.Action{Npgsql.NpgsqlConnection})">
            <summary>
            Callback to be invoked after database creation
            </summary>
        </member>
        <member name="M:Marten.Schema.ITenantDatabaseCreationExpressions.CreatePLV8">
            <summary>
            Create PLV8 extension for database
            </summary>
        </member>
        <member name="T:Marten.Schema.MartenAttribute">
            <summary>
            Base type of an Attribute that can be extended to add per field/property
            or per document type customization to the document storage
            </summary>
        </member>
        <member name="M:Marten.Schema.MartenAttribute.Modify(Marten.Schema.DocumentMapping)">
            <summary>
            Customize Document storage at the document level
            </summary>
            <param name="mapping"></param>
        </member>
        <member name="M:Marten.Schema.MartenAttribute.Modify(Marten.Schema.DocumentMapping,System.Reflection.MemberInfo)">
            <summary>
            Customize the Document storage for a single member
            </summary>
            <param name="mapping"></param>
            <param name="member"></param>
        </member>
        <member name="T:Marten.Schema.LastModifiedMetadataAttribute">
            <summary>
            Direct Marten to copy the last modified metadata to this member
            </summary>
        </member>
        <member name="T:Marten.Schema.TenantIdMetadataAttribute">
            <summary>
            Direct Marten to copy the tenant id metadata to this member
            </summary>
        </member>
        <member name="T:Marten.Schema.IsSoftDeletedMetadataAttributeAttribute">
            <summary>
            Direct Marten to copy the is soft deleted metadata to this member
            </summary>
        </member>
        <member name="T:Marten.Schema.SoftDeletedAtMetadataAttribute">
            <summary>
            Direct Marten to copy the soft deleted timestamp metadata to this member
            </summary>
        </member>
        <member name="T:Marten.Schema.DocumentTypeMetadataAttribute">
            <summary>
            Direct Marten to copy the hierarchical document type metadata to this member
            </summary>
        </member>
        <member name="T:Marten.Schema.MultiTenantedAttribute">
            <summary>
            Directs Marten to store this document type with conjoined multi-tenancy
            </summary>
        </member>
        <member name="F:Marten.Schema.PropertySearching.JSON_Locator_Only">
            <summary>
            Uses Postgresql's JSON locators to search within JSON data
            </summary>
        </member>
        <member name="F:Marten.Schema.PropertySearching.ContainmentOperator">
            <summary>
            Tries to use Postgresql's @> containment operator to search within JSON data
            </summary>
        </member>
        <member name="T:Marten.Schema.PropertySearchingAttribute">
            <summary>
            Customize the PropertySearching mode of a single document type
            </summary>
        </member>
        <member name="T:Marten.Schema.SoftDeletedAttribute">
            <summary>
            Marks a document type as "soft deleted"
            </summary>
        </member>
        <member name="P:Marten.Schema.SoftDeletedAttribute.Indexed">
            <summary>
            Creates an index on deleted documents
            </summary>
        </member>
        <member name="T:Marten.Schema.StructuralTypedAttribute">
            <summary>
            Allows you to duplicate storage with other classes of the same name
            </summary>
        </member>
        <member name="M:Marten.Schema.SubClasses.AddHierarchy">
            <summary>
                Programmatically directs Marten to map all the subclasses of <cref name="T" /> to a hierarchy of types.
                <c>Unadvised in projects with many types.</c>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Schema.SubClasses.AddHierarchy(Marten.MappedType[])">
            <summary>
                Programmatically directs Marten to map all the subclasses of <cref name="T" /> to a hierarchy of types
            </summary>
            <param name="allSubclassTypes">
                All the subclass types of <cref name="T" /> that you wish to map.
                You can use either params of <see cref="T:System.Type" /> or <see cref="T:Marten.MappedType" /> or a mix, since Type can implicitly
                convert to MappedType (without an alias)
            </param>
            <returns></returns>
        </member>
        <member name="T:Marten.Schema.SubClassMapping">
            <summary>
            IDocumentMapping implementation for a document type that's a subclass of a parent type, and
            maps to the parent storage
            </summary>
        </member>
        <member name="P:Marten.Schema.UniqueIndexAttribute.IsConcurrent">
            <summary>
            Specifies the index should be created in the background and not block/lock
            </summary>
        </member>
        <member name="P:Marten.Schema.UniqueIndexAttribute.IndexMethod">
            <summary>
            Specifies the type of index to create
            </summary>
        </member>
        <member name="P:Marten.Schema.UniqueIndexAttribute.IndexName">
            <summary>
            Specify the name of the index explicity
            </summary>
        </member>
        <member name="F:Marten.Schema.UniqueIndexAttribute.IndexType">
            <summary>
            Specify Index type
            </summary>
        </member>
        <member name="F:Marten.Schema.UniqueIndexAttribute.TenancyScope">
            <summary>
            Specify Tenancy for unique index
            </summary>
        </member>
        <member name="F:Marten.Schema.UniqueIndexType.DuplicatedField">
            <summary>
            Create a duplicated field for this unique index
            </summary>
        </member>
        <member name="F:Marten.Schema.UniqueIndexType.Computed">
            <summary>
            Use a computed expression without duplicating the field for this unique index
            </summary>
        </member>
        <member name="T:Marten.Schema.UseOptimisticConcurrencyAttribute">
            <summary>
            Directs Marten to use optimistic versioning checks when updating this document type
            </summary>
        </member>
        <member name="T:Marten.Schema.VersionAttribute">
            <summary>
            Direct Marten to make a field or property on a document be
            set and tracked as the document version.
            </summary>
        </member>
        <member name="T:Marten.IConnectionFactory">
            <summary>
                Factory interface to customize the construction of an NpgsqlConnection
                to the Postgresql database
            </summary>
        </member>
        <member name="M:Marten.IConnectionFactory.Create">
            <summary>
                Create a new, isolated connection to the Postgresql database
            </summary>
            <returns></returns>
        </member>
        <member name="T:Marten.IDiagnostics">
            <summary>
            Access to diagnostics about the current Marten IDocumentStore
            </summary>
        </member>
        <member name="M:Marten.IDiagnostics.PreviewCommand``2(Marten.Linq.ICompiledQuery{``0,``1})">
            <summary>
            Preview the database command that will be executed for this compiled query
            object
            </summary>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDiagnostics.ExplainPlan``2(Marten.Linq.ICompiledQuery{``0,``1})">
            <summary>
            Find the Postgresql EXPLAIN PLAN for this compiled query
            </summary>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDiagnostics.GetPostgresVersion">
            <summary>
            Method to fetch Postgres server version
            </summary>
            <returns>Returns version</returns>
        </member>
        <member name="T:Marten.IDocumentOperations">
            <summary>
            Basic storage operations for document types, but cannot initiate any actual writes
            </summary>
        </member>
        <member name="M:Marten.IDocumentOperations.Delete``1(``0)">
            <summary>
            Mark this entity for deletion upon the next call to SaveChanges()
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.Delete``1(System.Int32)">
            <summary>
            Mark an entity of type T with either a numeric or Guid id for deletion upon the next call to SaveChanges()
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.Delete``1(System.Int64)">
            <summary>
            Mark an entity of type T with either a numeric or Guid id for deletion upon the next call to SaveChanges()
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.Delete``1(System.Guid)">
            <summary>
            Mark an entity of type T with either a numeric or Guid id for deletion upon the next call to SaveChanges()
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.Delete``1(System.String)">
            <summary>
            Mark an entity of type T with a string id for deletion upon the next call to SaveChanges()
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.DeleteWhere``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Bulk delete all documents of type T matching the expression condition
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expression"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.Store``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Explicitly marks multiple documents as needing to be inserted or updated upon the next call to SaveChanges()
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.Store``1(``0[])">
            <summary>
            Explicitly marks one or more documents as needing to be inserted or updated upon the next call to SaveChanges()
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.Store``1(``0,System.Guid)">
            <summary>
            Explicitly marks a document as needing to be updated and supplies the
            current known version for the purpose of optimistic versioning checks
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
            <param name="version"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.StoreObjects(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            DocumentStore an enumerable of potentially mixed documents
            </summary>
            <param name="documents"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.QueueOperation(Marten.Internal.Operations.IStorageOperation)">
            <summary>
            Catch all mechanism to add additional database calls to the batched
            updates in SaveChanges()/SaveChangesAsync()
            </summary>
            <param name="storageOperation"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.Insert``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Explicitly marks a document as needing to be inserted upon the next call to SaveChanges().
            Will throw an exception if the document already exists
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.Insert``1(``0[])">
            <summary>
            Explicitly marks a document as needing to be inserted upon the next call to SaveChanges().
            Will throw an exception if the document already exists
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.Update``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Explicitly marks a document as needing to be updated upon the next call to SaveChanges().
            Will throw an exception if the document does not already exists
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.Update``1(``0[])">
            <summary>
            Explicitly marks a document as needing to be updated upon the next call to SaveChanges().
            Will throw an exception if the document does not already exists
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.InsertObjects(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Insert an enumerable of potentially mixed documents. Will throw exceptions
            if a document overwrite is detected
            </summary>
            <param name="documents"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.HardDelete``1(``0)">
            <summary>
            Mark this entity for a "hard" deletion upon the next call to SaveChanges()
            that will delete the underlying database row
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.HardDelete``1(System.Int32)">
            <summary>
            Mark an entity of type T with either a numeric or Guid id for "hard" deletion upon the next call to SaveChanges()
            that will delete the underlying database row
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.HardDelete``1(System.Int64)">
            <summary>
            Mark an entity of type T with either a numeric or Guid id for hard deletion upon the next call to SaveChanges()
            that will delete the underlying database row
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.HardDelete``1(System.Guid)">
            <summary>
            Mark an entity of type T with either a numeric or Guid id for hard deletion upon the next call to SaveChanges()
            that will delete the underlying database row
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.HardDelete``1(System.String)">
            <summary>
            Mark an entity of type T with a string id for hard deletion upon the next call to SaveChanges()
            that will delete the underlying database row
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.HardDeleteWhere``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Bulk hard delete all documents of type T matching the expression condition
            that will delete the underlying database rows
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expression"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.UndoDeleteWhere``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            For soft-deleted document types, this is a one sized fits all mechanism to reverse the
            soft deletion tracking
            </summary>
            <param name="expression"></param>
            <typeparam name="T"></typeparam>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="T:Marten.IDocumentPolicy">
            <summary>
            Represents a pluggable configuration convention for all persisted documents
            </summary>
        </member>
        <member name="T:Marten.IDocumentSession">
            <summary>
            Interface for querying a document database and unit of work updates
            </summary>
        </member>
        <member name="M:Marten.IDocumentSession.SaveChanges">
            <summary>
            Saves all the pending changes and deletions to the server in a single Postgresql transaction.
            </summary>
        </member>
        <member name="M:Marten.IDocumentSession.SaveChangesAsync(System.Threading.CancellationToken)">
            <summary>
            Asynchronously saves all the pending changes and deletions to the server in a single Postgresql transaction
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.IDocumentSession.PendingChanges">
            <summary>
            List of all the pending changes to this IDocumentSession
            </summary>
        </member>
        <member name="P:Marten.IDocumentSession.Events">
            <summary>
            Access to the event store functionality
            </summary>
        </member>
        <member name="P:Marten.IDocumentSession.Concurrency">
            <summary>
            Override whether or not this session honors optimistic concurrency checks
            </summary>
        </member>
        <member name="P:Marten.IDocumentSession.Listeners">
            <summary>
            Writeable list of the listeners for this session
            </summary>
        </member>
        <member name="M:Marten.IDocumentSession.Eject``1(``0)">
            <summary>
            Completely remove the document from this session's unit of work tracking and identity map caching
            </summary>
            <typeparam name="T"></typeparam>
            <param name="document"></param>
        </member>
        <member name="M:Marten.IDocumentSession.EjectAllOfType(System.Type)">
            <summary>
            Completely remove all the documents of given type from this session's unit of work tracking and identity map caching
            </summary>
            <typeparam name="T"></typeparam>
            <param name="type"></param>
        </member>
        <member name="P:Marten.IDocumentSession.LastModifiedBy">
            <summary>
            Optional metadata describing the user name or
            process name for this unit of work
            </summary>
        </member>
        <member name="M:Marten.IDocumentSession.SetHeader(System.String,System.Object)">
            <summary>
            Set an optional user defined metadata value by key
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Marten.IDocumentSession.GetHeader(System.String)">
            <summary>
            Get an optional user defined metadata value by key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentSession.ForTenant(System.String)">
            <summary>
            Access data from another tenant and apply document or event updates to this
            IDocumentSession for a separate tenant
            </summary>
            <param name="tenantId"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.ILoadByKeys`1.ById``1(``0[])">
            <summary>
            Supply the document id's to load
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.ILoadByKeys`1.ByIdAsync``1(``0[])">
            <summary>
            Supply the document id's to load asynchronously
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.ILoadByKeys`1.ById``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Supply the document id's to load
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.ILoadByKeys`1.ByIdAsync``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)">
            <summary>
            Supply the document id's to load asynchronously
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="keys"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.IDocumentSessionListener">
            <summary>
            Used to listen to and intercept operations within an IDocumentSession.SaveChanges()/SaveChangesAsync()
            operation
            </summary>
        </member>
        <member name="M:Marten.IDocumentSessionListener.BeforeSaveChanges(Marten.IDocumentSession)">
            <summary>
            Called just after IDocumentSession.SaveChanges() is called, but before
            any database calls are made
            </summary>
            <param name="session"></param>
        </member>
        <member name="M:Marten.IDocumentSessionListener.BeforeSaveChangesAsync(Marten.IDocumentSession,System.Threading.CancellationToken)">
            <summary>
            Called just after IDocumentSession.SaveChanges() is called,
            but before any database calls are made
            </summary>
            <param name="session"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentSessionListener.AfterCommit(Marten.IDocumentSession,Marten.Services.IChangeSet)">
            <summary>
            After an IDocumentSession is committed
            </summary>
            <param name="session"></param>
            <param name="commit"></param>
        </member>
        <member name="M:Marten.IDocumentSessionListener.AfterCommitAsync(Marten.IDocumentSession,Marten.Services.IChangeSet,System.Threading.CancellationToken)">
            <summary>
            After an IDocumentSession is committed
            </summary>
            <param name="session"></param>
            <param name="commit"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentSessionListener.DocumentLoaded(System.Object,System.Object)">
            <summary>
            Called after a document is loaded
            </summary>
        </member>
        <member name="M:Marten.IDocumentSessionListener.DocumentAddedForStorage(System.Object,System.Object)">
            <summary>
            Called after a document is explicitly added to a session
            as a staged insert or update
            </summary>
        </member>
        <member name="T:Marten.DocumentSessionListenerBase">
            <summary>
            Base class to help create custom IDocumentSessionListener classes
            </summary>
        </member>
        <member name="T:Marten.IDocumentSourceCode">
            <summary>
            Diagnostic access to all the source code generated by Marten
            for a given document type
            </summary>
        </member>
        <member name="P:Marten.IDocumentSourceCode.QueryOnlyStorageCode">
            <summary>
            IDocumentStorage code used within QuerySession
            </summary>
        </member>
        <member name="P:Marten.IDocumentSourceCode.LightweightStorageCode">
            <summary>
            IDocumentStorage code used within LightweightSession
            </summary>
        </member>
        <member name="P:Marten.IDocumentSourceCode.IdentityMapStorageCode">
            <summary>
            IDocumentStorage code used within IdentityMapSession
            </summary>
        </member>
        <member name="P:Marten.IDocumentSourceCode.DirtyTrackingStorageCode">
            <summary>
            IDocumentStorage code used within DirtyTrackingSession
            </summary>
        </member>
        <member name="P:Marten.IDocumentSourceCode.BulkLoaderCode">
            <summary>
            Bulk loading code
            </summary>
        </member>
        <member name="P:Marten.IDocumentSourceCode.UpsertOperationCode">
            <summary>
            Code that "upserts" a single document
            </summary>
        </member>
        <member name="P:Marten.IDocumentSourceCode.UpdateOperationCode">
            <summary>
            Code that updates a single document
            </summary>
        </member>
        <member name="P:Marten.IDocumentSourceCode.InsertOperationCode">
            <summary>
            Code that inserts a single document
            </summary>
        </member>
        <member name="P:Marten.IDocumentSourceCode.QueryOnlySelectorCode">
            <summary>
            Code for loading the document type within QuerySession
            </summary>
        </member>
        <member name="P:Marten.IDocumentSourceCode.LightweightSelectorCode">
            <summary>
            Code for loading the document type within LightweightSession
            </summary>
        </member>
        <member name="P:Marten.IDocumentSourceCode.IdentityMapSelectorCode">
            <summary>
            Code for loading the document type within IdentityMapSession
            </summary>
        </member>
        <member name="P:Marten.IDocumentSourceCode.DirtyCheckingSelectorCode">
            <summary>
            Code for loading the document type within DirtyCheckingSession
            </summary>
        </member>
        <member name="T:Marten.IDocumentStore">
            <summary>
            The core abstraction for a Marten document and event store. This should probably be scoped as a
            singleton in your system
            </summary>
        </member>
        <member name="P:Marten.IDocumentStore.Options">
            <summary>
            Information about the current configuration of this IDocumentStore
            </summary>
        </member>
        <member name="P:Marten.IDocumentStore.Schema">
            <summary>
                Information about the document and event storage
            </summary>
        </member>
        <member name="P:Marten.IDocumentStore.Advanced">
            <summary>
                Infrequently used operations like document cleaning and the initial store configuration
            </summary>
        </member>
        <member name="P:Marten.IDocumentStore.Diagnostics">
            <summary>
                Access to Marten's diagnostics for trouble shooting
            </summary>
        </member>
        <member name="M:Marten.IDocumentStore.BulkInsert``1(System.Collections.Generic.IReadOnlyCollection{``0},Marten.BulkInsertMode,System.Int32)">
            <summary>
                Uses Postgresql's COPY ... FROM STDIN BINARY feature to efficiently store
                a large number of documents of type "T" to the database. This operation is transactional.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="documents"></param>
            <param name="mode"></param>
            <param name="batchSize"></param>
        </member>
        <member name="M:Marten.IDocumentStore.BulkInsert``1(System.String,System.Collections.Generic.IReadOnlyCollection{``0},Marten.BulkInsertMode,System.Int32)">
            <summary>
                Uses Postgresql's COPY ... FROM STDIN BINARY feature to efficiently store
                a large number of documents of type "T" to the database. This operation is transactional.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="tenantId"></param>
            <param name="documents"></param>
            <param name="mode"></param>
            <param name="batchSize"></param>
        </member>
        <member name="M:Marten.IDocumentStore.BulkInsertAsync``1(System.Collections.Generic.IReadOnlyCollection{``0},Marten.BulkInsertMode,System.Int32,System.Threading.CancellationToken)">
            <summary>
                Uses Postgresql's COPY ... FROM STDIN BINARY feature to efficiently store
                a large number of documents of type "T" to the database. This operation is transactional.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="documents"></param>
            <param name="mode"></param>
            <param name="batchSize"></param>
        </member>
        <member name="M:Marten.IDocumentStore.BulkInsertAsync``1(System.String,System.Collections.Generic.IReadOnlyCollection{``0},Marten.BulkInsertMode,System.Int32,System.Threading.CancellationToken)">
            <summary>
                Uses Postgresql's COPY ... FROM STDIN BINARY feature to efficiently store
                a large number of documents of type "T" to the database. This operation is transactional.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="tenantId"></param>
            <param name="documents"></param>
            <param name="mode"></param>
            <param name="batchSize"></param>
        </member>
        <member name="M:Marten.IDocumentStore.OpenSession(Marten.DocumentTracking,System.Data.IsolationLevel)">
            <summary>
                Open a new IDocumentSession with the supplied DocumentTracking.
                "IdentityOnly" is the default.
            </summary>
            <param name="tracking"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.OpenSession(System.String,Marten.DocumentTracking,System.Data.IsolationLevel)">
            <summary>
                Open a new IDocumentSession with the supplied DocumentTracking.
                "IdentityOnly" is the default.
            </summary>
            <param name="tracking"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.OpenSession(Marten.Services.SessionOptions)">
            <summary>
                Open a new IDocumentSession with the supplied DocumentTracking.
                "IdentityOnly" is the default.
            </summary>
            <param name="options">Additional options for session</param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.LightweightSession(System.Data.IsolationLevel)">
            <summary>
                Convenience method to create a new "lightweight" IDocumentSession with no IdentityMap
                or automatic dirty checking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.LightweightSession(System.String,System.Data.IsolationLevel)">
            <summary>
                Convenience method to create a new "lightweight" IDocumentSession with no IdentityMap
                or automatic dirty checking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.DirtyTrackedSession(System.Data.IsolationLevel)">
            <summary>
                Convenience method to create an IDocumentSession with both IdentityMap and automatic
                dirty checking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.DirtyTrackedSession(System.String,System.Data.IsolationLevel)">
            <summary>
                Convenience method to create an IDocumentSession with both IdentityMap and automatic
                dirty checking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.QuerySession">
            <summary>
                Opens a read-only IQuerySession to the current document store for efficient
                querying without any underlying object tracking.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.QuerySession(System.String)">
            <summary>
                Opens a read-only IQuerySession to the current document store for efficient
                querying without any underlying object tracking.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.QuerySession(Marten.Services.SessionOptions)">
            <summary>
                Opens a read-only IQuerySession to the current document store for efficient
                querying without any underlying object tracking.
            </summary>
            <param name="options">Additional options for session. DocumentTracking is not applicable for IQuerySession.</param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.BulkInsertDocuments(System.Collections.Generic.IEnumerable{System.Object},Marten.BulkInsertMode,System.Int32)">
            <summary>
                Bulk insert a potentially mixed enumerable of document types
            </summary>
            <param name="documents"></param>
            <param name="mode"></param>
            <param name="batchSize"></param>
        </member>
        <member name="M:Marten.IDocumentStore.BulkInsertDocuments(System.String,System.Collections.Generic.IEnumerable{System.Object},Marten.BulkInsertMode,System.Int32)">
            <summary>
                Bulk insert a potentially mixed enumerable of document types
            </summary>
            <param name="documents"></param>
            <param name="mode"></param>
            <param name="batchSize"></param>
        </member>
        <member name="M:Marten.IDocumentStore.BulkInsertDocumentsAsync(System.Collections.Generic.IEnumerable{System.Object},Marten.BulkInsertMode,System.Int32,System.Threading.CancellationToken)">
            <summary>
                Bulk insert a potentially mixed enumerable of document types
            </summary>
            <param name="documents"></param>
            <param name="mode"></param>
            <param name="batchSize"></param>
        </member>
        <member name="M:Marten.IDocumentStore.BulkInsertDocumentsAsync(System.String,System.Collections.Generic.IEnumerable{System.Object},Marten.BulkInsertMode,System.Int32,System.Threading.CancellationToken)">
            <summary>
                Bulk insert a potentially mixed enumerable of document types
            </summary>
            <param name="documents"></param>
            <param name="mode"></param>
            <param name="batchSize"></param>
        </member>
        <member name="M:Marten.IDocumentStore.BuildProjectionDaemon(Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Build a new instance of the asynchronous projection daemon to use interactively
            in your own code
            </summary>
            <param name="logger">Override the logger inside this instance of the async daemon</param>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.FindById``1(System.String)">
            <summary>
            Load or find only the document json by string id for a document of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.FindById``1(System.Int32)">
            <summary>
            Load or find only the document json by numeric or Guid id for a document of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.FindById``1(System.Int64)">
            <summary>
            Load or find only the document json by numeric or Guid id for a document of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.FindById``1(System.Guid)">
            <summary>
            Load or find only the document json by numeric or Guid id for a document of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.FindByIdAsync``1(System.String,System.Threading.CancellationToken)">
            <summary>
            Asynchronously load or find only the document json by string id for a document of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.FindByIdAsync``1(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Asynchronously load or find only the document json by numeric or Guid id for a document of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.FindByIdAsync``1(System.Int64,System.Threading.CancellationToken)">
            <summary>
            Asynchronously load or find only the document json by numeric or Guid id for a document of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.FindByIdAsync``1(System.Guid,System.Threading.CancellationToken)">
            <summary>
            Asynchronously load or find only the document json by numeric or Guid id for a document of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.StreamById``1(System.Int32,System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Write the raw persisted JSON for a single document found by id to the supplied stream. Returns false
            if the document cannot be found
            </summary>
            <param name="id"></param>
            <param name="destination"></param>
            <param name="token"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.StreamById``1(System.Int64,System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Write the raw persisted JSON for a single document found by id to the supplied stream. Returns false
            if the document cannot be found
            </summary>
            <param name="id"></param>
            <param name="destination"></param>
            <param name="token"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.StreamById``1(System.String,System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Write the raw persisted JSON for a single document found by id to the supplied stream. Returns false
            if the document cannot be found
            </summary>
            <param name="id"></param>
            <param name="destination"></param>
            <param name="token"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.StreamById``1(System.Guid,System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Write the raw persisted JSON for a single document found by id to the supplied stream. Returns false
            if the document cannot be found
            </summary>
            <param name="id"></param>
            <param name="destination"></param>
            <param name="token"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Marten.IMartenLogger">
            <summary>
            Records command usage, schema changes, and sessions within Marten
            </summary>
        </member>
        <member name="M:Marten.IMartenLogger.StartSession(Marten.IQuerySession)">
            <summary>
            Called when the session is initialized
            </summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IMartenLogger.SchemaChange(System.String)">
            <summary>
            Capture any DDL executed at runtime by Marten
            </summary>
            <param name="sql"></param>
        </member>
        <member name="T:Marten.IMartenSessionLogger">
            <summary>
            Use to create custom logging within an IQuerySession or IDocumentSession
            </summary>
        </member>
        <member name="M:Marten.IMartenSessionLogger.LogSuccess(Npgsql.NpgsqlCommand)">
            <summary>
            Log a command that executed successfully
            </summary>
            <param name="command"></param>
        </member>
        <member name="M:Marten.IMartenSessionLogger.LogFailure(Npgsql.NpgsqlCommand,System.Exception)">
            <summary>
            Log a command that failed
            </summary>
            <param name="command"></param>
            <param name="ex"></param>
        </member>
        <member name="M:Marten.IMartenSessionLogger.RecordSavedChanges(Marten.IDocumentSession,Marten.Services.IChangeSet)">
            <summary>
            Called immediately after committing an IDocumentSession
            through SaveChanges() or SaveChangesAsync()
            </summary>
            <param name="session"></param>
            <param name="commit"></param>
        </member>
        <member name="M:Marten.IMartenSessionLogger.OnBeforeExecute(Npgsql.NpgsqlCommand)">
            <summary>
            Called just before a command is to be executed. Use this to create
            performance logging of Marten operations
            </summary>
            <param name="command"></param>
        </member>
        <member name="M:Marten.Internal.CodeGeneration.FrameCollectionExtensions.SetMemberValue(LamarCodeGeneration.FramesCollection,System.Reflection.MemberInfo,System.String,System.Type,LamarCodeGeneration.GeneratedType)">
            <summary>
            Generates the necessary setter code to set a value of a document.
            Handles internal/private setters
            </summary>
            <param name="frames"></param>
            <param name="member"></param>
            <param name="variableName"></param>
            <param name="documentType"></param>
            <param name="generatedType"></param>
        </member>
        <member name="T:Marten.Internal.CodeGeneration.IDocumentSelector">
            <summary>
            Strictly a marker interface that tells the compiled query
            generation to use a new selector per session
            </summary>
        </member>
        <member name="P:Marten.Internal.IMartenSession.Concurrency">
            <summary>
            Override whether or not this session honors optimistic concurrency checks
            </summary>
        </member>
        <member name="P:Marten.Internal.IMartenSession.CausationId">
            <summary>
            Optional metadata describing the causation id for this
            unit of work
            </summary>
        </member>
        <member name="P:Marten.Internal.IMartenSession.CorrelationId">
            <summary>
            Optional metadata describing the correlation id for this
            unit of work
            </summary>
        </member>
        <member name="P:Marten.Internal.IMartenSession.LastModifiedBy">
            <summary>
            Optional metadata describing the user name or
            process name for this unit of work
            </summary>
        </member>
        <member name="P:Marten.Internal.IMartenSession.Headers">
            <summary>
            Optional metadata values. This may be null.
            </summary>
        </member>
        <member name="M:Marten.Internal.Sessions.DocumentSessionBase.#ctor(Marten.StoreOptions)">
            <summary>
            Used for code generation
            </summary>
        </member>
        <member name="M:Marten.Internal.Sessions.DocumentSessionBase.ForTenant(System.String)">
            <summary>
                Access data from another tenant and apply document or event updates to this
                IDocumentSession for a separate tenant
            </summary>
            <param name="tenantId"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Internal.Sessions.DocumentSessionBase.UndoDeleteWhere``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            For soft-deleted document types, this is a one sized fits all mechanism to reverse the
            soft deletion tracking
            </summary>
            <param name="expression"></param>
            <typeparam name="T"></typeparam>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Marten.Internal.Sessions.QuerySession.#ctor(Marten.StoreOptions)">
            <summary>
            Used for code generation
            </summary>
        </member>
        <member name="M:Marten.Internal.Sessions.QuerySession.QueryStorageFor``2">
            <summary>
            This returns the query-only version of the document storage
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TId"></typeparam>
            <returns></returns>
            <exception cref="T:Marten.Exceptions.DocumentIdTypeMismatchException"></exception>
        </member>
        <member name="P:Marten.Internal.Sessions.QuerySession.Headers">
            <summary>
            This is meant to be lazy created, and can be null
            </summary>
        </member>
        <member name="M:Marten.Internal.Storage.IDocumentStorage`2.SetIdentity(`0,`1)">
            <summary>
            Assign the given identity to the document
            </summary>
            <param name="document"></param>
            <param name="identity"></param>
        </member>
        <member name="M:Marten.IQuerySession.Load``1(System.String)">
            <summary>
            Find or load a single document of type T by a string id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadAsync``1(System.String,System.Threading.CancellationToken)">
            <summary>
            Asynchronously find or load a single document of type T by a string id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.Load``1(System.Int32)">
            <summary>
            Load or find a single document of type T with either a numeric or Guid id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.Load``1(System.Int64)">
            <summary>
            Load or find a single document of type T with either a numeric or Guid id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.Load``1(System.Guid)">
            <summary>
            Load or find a single document of type T with either a numeric or Guid id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadAsync``1(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Asynchronously load or find a single document of type T with either a numeric or Guid id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadAsync``1(System.Int64,System.Threading.CancellationToken)">
            <summary>
            Asynchronously load or find a single document of type T with either a numeric or Guid id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadAsync``1(System.Guid,System.Threading.CancellationToken)">
            <summary>
            Asynchronously load or find a single document of type T with either a numeric or Guid id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.Query``1">
            <summary>
            Use Linq operators to query the documents
            stored in Postgresql
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.Query``1(System.String,System.Object[])">
            <summary>
            Queries the document storage table for the document type T by supplied SQL. See http://jasperfx.github.io/marten/documentation/documents/querying/sql/ for more information on usage.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.StreamJson``1(System.IO.Stream,System.Threading.CancellationToken,System.String,System.Object[])">
            <summary>
            Stream the results of a user-supplied query directly to a stream as a JSON array
            </summary>
            <param name="destination"></param>
            <param name="token"></param>
            <param name="sql"></param>
            <param name="parameters"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.StreamJson``1(System.IO.Stream,System.String,System.Object[])">
            <summary>
            Stream the results of a user-supplied query directly to a stream as a JSON array
            </summary>
            <param name="destination"></param>
            <param name="token"></param>
            <param name="sql"></param>
            <param name="parameters"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.QueryAsync``1(System.String,System.Threading.CancellationToken,System.Object[])">
            <summary>
            Asynchronously queries the document storage table for the document type T by supplied SQL. See http://jasperfx.github.io/marten/documentation/documents/querying/sql/ for more information on usage.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sql"></param>
            <param name="token"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.QueryAsync``1(System.String,System.Object[])">
            <summary>
            Asynchronously queries the document storage table for the document type T by supplied SQL. See http://jasperfx.github.io/marten/documentation/documents/querying/sql/ for more information on usage.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sql"></param>
            <param name="token"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.CreateBatchQuery">
            <summary>
            Define a batch of deferred queries and load operations to be conducted in one asynchronous request to the
            database for potentially performance
            </summary>
            <returns></returns>
        </member>
        <member name="P:Marten.IQuerySession.Connection">
            <summary>
            The currently open Npgsql connection for this session. Use with caution.
            </summary>
        </member>
        <member name="P:Marten.IQuerySession.Logger">
            <summary>
            The session specific logger for this session. Can be set for better integration
            with custom diagnostics
            </summary>
        </member>
        <member name="P:Marten.IQuerySession.RequestCount">
            <summary>
            Request count
            </summary>
        </member>
        <member name="P:Marten.IQuerySession.DocumentStore">
            <summary>
            The document store that created this session
            </summary>
        </member>
        <member name="P:Marten.IQuerySession.Events">
            <summary>
            Access to the event store functionality
            </summary>
        </member>
        <member name="M:Marten.IQuerySession.Query``2(Marten.Linq.ICompiledQuery{``0,``1})">
            <summary>
            A query that is compiled so a copy of the DbCommand can be used directly in subsequent requests.
            </summary>
            <typeparam name="TDoc">The document</typeparam>
            <typeparam name="TOut">The output</typeparam>
            <param name="query">The instance of a compiled query</param>
            <returns>A single item query result</returns>
        </member>
        <member name="M:Marten.IQuerySession.QueryAsync``2(Marten.Linq.ICompiledQuery{``0,``1},System.Threading.CancellationToken)">
            <summary>
            An async query that is compiled so a copy of the DbCommand can be used directly in subsequent requests.
            </summary>
            <typeparam name="TDoc">The document</typeparam>
            <typeparam name="TOut">The output</typeparam>
            <param name="query">The instance of a compiled query</param>
            <param name="token">A cancellation token</param>
            <returns>A task for a single item query result</returns>
        </member>
        <member name="M:Marten.IQuerySession.StreamJsonOne``2(Marten.Linq.ICompiledQuery{``0,``1},System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Stream a single JSON document to the destination using a compiled query
            </summary>
            <param name="query"></param>
            <param name="destination"></param>
            <param name="token"></param>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TOut"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.StreamJsonMany``2(Marten.Linq.ICompiledQuery{``0,``1},System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Stream many documents as a JSON array to the destination using a compiled query
            </summary>
            <param name="query"></param>
            <param name="destination"></param>
            <param name="token"></param>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TOut"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.ToJsonOne``2(Marten.Linq.ICompiledQuery{``0,``1},System.Threading.CancellationToken)">
            <summary>
            Fetch the JSON representation of a single document using a compiled query
            </summary>
            <param name="query"></param>
            <param name="token"></param>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TOut"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.ToJsonMany``2(Marten.Linq.ICompiledQuery{``0,``1},System.Threading.CancellationToken)">
            <summary>
            Fetch the JSON array representation of a list of documents using a compiled query
            </summary>
            <param name="query"></param>
            <param name="token"></param>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TOut"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadMany``1(System.String[])">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadMany``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadMany``1(System.Guid[])">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadMany``1(System.Collections.Generic.IEnumerable{System.Guid})">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadMany``1(System.Int32[])">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadMany``1(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadMany``1(System.Int64[])">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadMany``1(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.String[])">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Guid[])">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Collections.Generic.IEnumerable{System.Guid})">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Int32[])">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Int64[])">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Threading.CancellationToken,System.String[])">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Threading.CancellationToken,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Threading.CancellationToken,System.Guid[])">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Threading.CancellationToken,System.Collections.Generic.IEnumerable{System.Guid})">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Threading.CancellationToken,System.Int32[])">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Threading.CancellationToken,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Threading.CancellationToken,System.Int64[])">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Threading.CancellationToken,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="P:Marten.IQuerySession.Json">
            <summary>
            Directly load the persisted JSON data for documents by Id
            </summary>
        </member>
        <member name="P:Marten.IQuerySession.CausationId">
            <summary>
            Optional metadata describing the causation id for this
            unit of work
            </summary>
        </member>
        <member name="P:Marten.IQuerySession.CorrelationId">
            <summary>
            Optional metadata describing the correlation id for this
            unit of work
            </summary>
        </member>
        <member name="M:Marten.IQuerySession.VersionFor``1(``0)">
            <summary>
            Retrieve the current known version of the given document
            according to this session. Will return null if the document is
            not part of this session
            </summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.Search``1(System.String,System.String)">
            <summary>
            Performs a full text search against <typeparamref name="TDoc"/>
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <param name="regConfig">The dictionary config passed to the 'to_tsquery' function, must match the config parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)"/></param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.IQuerySession.SearchAsync``1(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Performs an asynchronous full text search against <typeparamref name="TDoc"/>
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <param name="regConfig">The dictionary config passed to the 'to_tsquery' function, must match the config parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)"/></param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.IQuerySession.PlainTextSearch``1(System.String,System.String)">
            <summary>
            Performs a full text search against <typeparamref name="TDoc"/> using the 'plainto_tsquery' search function
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <param name="regConfig">The dictionary config passed to the 'to_tsquery' function, must match the config parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)"/></param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.IQuerySession.PlainTextSearchAsync``1(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Performs an asynchronous full text search against <typeparamref name="TDoc"/> using the 'plainto_tsquery' function
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <param name="regConfig">The dictionary config passed to the 'to_tsquery' function, must match the config parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)"/></param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.IQuerySession.PhraseSearch``1(System.String,System.String)">
            <summary>
            Performs a full text search against <typeparamref name="TDoc"/> using the 'phraseto_tsquery' search function
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <param name="regConfig">The dictionary config passed to the 'to_tsquery' function, must match the config parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)"/></param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.IQuerySession.PhraseSearchAsync``1(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Performs an asynchronous full text search against <typeparamref name="TDoc"/> using the 'phraseto_tsquery' search function
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <param name="regConfig">The dictionary config passed to the 'to_tsquery' function, must match the config parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)"/></param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.IQuerySession.WebStyleSearch``1(System.String,System.String)">
            <summary>
            Performs a full text search against <typeparamref name="TDoc"/> using the 'websearch_to_tsquery' search function
            </summary>
            <param name="searchTerm">The text to search for.  Uses an alternative syntax to the other search functions, similar to the one used by web search engines</param>
            <param name="regConfig">The dictionary config passed to the 'websearch_to_tsquery' function, must match the config parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)"/></param>
            <remarks>
            Supported from Postgres 11
            See: https://www.postgresql.org/docs/11/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.IQuerySession.WebStyleSearchAsync``1(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Performs an asynchronous full text search against <typeparamref name="TDoc"/> using the 'websearch_to_tsquery' search function
            </summary>
            <param name="searchTerm">The text to search for.  Uses an alternative syntax to the other search functions, similar to the one used by web search engines</param>
            <param name="regConfig">The dictionary config passed to the 'websearch_to_tsquery' function, must match the config parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)"/></param>
            <param name="token"></param>
            <remarks>
            Supported from Postgres 11
            See: https://www.postgresql.org/docs/11/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.IQuerySession.MetadataFor``1(``0)">
            <summary>
                Fetch the entity version and last modified time from the database
            </summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.MetadataForAsync``1(``0,System.Threading.CancellationToken)">
            <summary>
                Fetch the entity version and last modified time from the database
            </summary>
            <param name="entity"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.ForTenant(System.String)">
            <summary>
            Access data from another tenant and apply document or event updates to this
            IDocumentSession for a separate tenant
            </summary>
            <param name="tenantId"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.IReadOnlyStoreOptions.Advanced">
            <summary>
            Uncommonly used configuration items
            </summary>
        </member>
        <member name="P:Marten.IReadOnlyStoreOptions.DatabaseSchemaName">
            <summary>
                Sets the database default schema name used to store the documents.
            </summary>
        </member>
        <member name="P:Marten.IReadOnlyStoreOptions.Events">
            <summary>
                Configuration of event streams and projections
            </summary>
        </member>
        <member name="P:Marten.IReadOnlyStoreOptions.Linq">
            <summary>
            Custom Linq query parsers applied to this DocumentStore
            </summary>
        </member>
        <member name="P:Marten.IReadOnlyStoreOptions.NameDataLength">
            <summary>
                Used to validate database object name lengths against Postgresql's NAMEDATALEN property to avoid
                Marten getting confused when comparing database schemas against the configuration. See
                https://www.postgresql.org/docs/current/static/sql-syntax-lexical.html
                for more information. This does NOT adjust NAMEDATALEN for you.
            </summary>
        </member>
        <member name="P:Marten.IReadOnlyStoreOptions.EnumStorage">
            <summary>
            Gets Enum values stored as either integers or strings. This is configured on your ISerializer
            </summary>
        </member>
        <member name="P:Marten.IReadOnlyStoreOptions.UpdateBatchSize">
            <summary>
                Sets the batch size for updating or deleting documents in IDocumentSession.SaveChanges() /
                IUnitOfWork.ApplyChanges()
            </summary>
        </member>
        <member name="P:Marten.IReadOnlyStoreOptions.Tenancy">
            <summary>
            Access to information about document store tenants configured in this application
            </summary>
        </member>
        <member name="M:Marten.IReadOnlyStoreOptions.Serializer">
            <summary>
            Access to the underlying Marten serializer
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IReadOnlyStoreOptions.Logger">
            <summary>
            Access to the attached Marten logger
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IReadOnlyStoreOptions.RetryPolicy">
            <summary>
            Access to the configured retry policy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IReadOnlyStoreOptions.AllKnownDocumentTypes">
            <summary>
            Retrieve a list of all the currently known document types
            in this Martne store
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IReadOnlyStoreOptions.FindOrResolveDocumentType(System.Type)">
            <summary>
            Finds or resolves the configuration for a given document type
            If the documentType is a subclass, you will retrieve the root
            parent document configuration.
            </summary>
            <param name="documentType"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.IRetryPolicy">
            <summary>
            Interface defining the retry policy for handling NpgqlException with transient failures
            </summary>
        </member>
        <member name="M:Marten.IRetryPolicy.Execute(System.Action)">
            <summary>
            Execute operation with the relevant retry policy
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:Marten.IRetryPolicy.Execute``1(System.Func{``0})">
            <summary>
            Execute operation with the relevant retry policy and return result
            </summary>
            <param name="operation"></param>
            <typeparam name="TResult"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IRetryPolicy.ExecuteAsync(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            Async execute operation with the relevant retry policy
            </summary>
            <param name="operation"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IRetryPolicy.ExecuteAsync``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
            <summary>
            Async Execute operation with the relevant retry policy and return result
            </summary>
            <param name="operation"></param>
            <param name="cancellationToken"></param>
            <typeparam name="TResult"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Marten.ValueCasting">
            <summary>
            When selecting data through Linq Select() transforms,
            should the data elements returned from Postgresql be
            cast to their raw types or simple strings
            </summary>
        </member>
        <member name="F:Marten.ValueCasting.Strict">
            <summary>
            Json fields will be returned with their values cast to
            the proper type. I.e., {"number": 1}
            </summary>
        </member>
        <member name="F:Marten.ValueCasting.Relaxed">
            <summary>
            Json fields will be returned with their values in simple
            string values. I.e., {"number": "1"}
            </summary>
        </member>
        <member name="M:Marten.ISerializer.ToJson(System.Object)">
            <summary>
            Serialize the document object into a JSON string
            </summary>
            <param name="document"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.ISerializer.FromJson``1(System.IO.Stream)">
            <summary>
            Deserialize a JSON string stream into an object of type T
            </summary>
        </member>
        <member name="M:Marten.ISerializer.FromJson``1(System.Data.Common.DbDataReader,System.Int32)">
            <summary>
            Deserialize a JSON string into an object of type T
            </summary>
        </member>
        <member name="M:Marten.ISerializer.FromJsonAsync``1(System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Deserialize a JSON string stream into an object of type T
            </summary>
        </member>
        <member name="M:Marten.ISerializer.FromJsonAsync``1(System.Data.Common.DbDataReader,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Deserialize a JSON string into an object of type T
            </summary>
        </member>
        <member name="M:Marten.ISerializer.FromJson(System.Type,System.IO.Stream)">
            <summary>
            Deserialize a JSON string stream into an object of type T
            </summary>
        </member>
        <member name="M:Marten.ISerializer.FromJson(System.Type,System.Data.Common.DbDataReader,System.Int32)">
            <summary>
            Deserialize a JSON string into the supplied Type
            </summary>
        </member>
        <member name="M:Marten.ISerializer.FromJsonAsync(System.Type,System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Deserialize a JSON string stream into an object of type T
            </summary>
        </member>
        <member name="M:Marten.ISerializer.FromJsonAsync(System.Type,System.Data.Common.DbDataReader,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Deserialize a JSON string into the supplied Type
            </summary>
        </member>
        <member name="M:Marten.ISerializer.ToCleanJson(System.Object)">
            <summary>
            Serialize a document without any extra
            type handling metadata
            </summary>
            <param name="document"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.ISerializer.EnumStorage">
            <summary>
            Just gotta tell Marten if enum's are stored
            as int's or string's in the JSON
            </summary>
        </member>
        <member name="P:Marten.ISerializer.Casing">
            <summary>
            Specify whether properties in the JSON document should use Camel or Pascal casing.
            </summary>
        </member>
        <member name="M:Marten.ISerializer.ToJsonWithTypes(System.Object)">
            <summary>
            Write the JSON for a document with embedded
            type information. This is used inside the patching API
            to handle polymorphic collections
            </summary>
            <param name="document"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.ISerializer.ValueCasting">
            <summary>
            Controls how the Linq Select() behavior needs to work in the database
            </summary>
        </member>
        <member name="T:Marten.Casing">
            <summary>
            Governs the JSON serialization behavior of how .Net
            member names are persisted in the JSON stored in
            the database
            </summary>
        </member>
        <member name="F:Marten.Casing.Default">
            <summary>
            Exactly mimic the .Net member names in the JSON persisted to the database
            </summary>
        </member>
        <member name="F:Marten.Casing.CamelCase">
            <summary>
            Force the .Net member names to camel casing when serialized to JSON in
            the database
            </summary>
        </member>
        <member name="F:Marten.Casing.SnakeCase">
            <summary>
            Force the .Net member names to snake casing when serialized to JSON in
            the database
            </summary>
        </member>
        <member name="T:Marten.CollectionStorage">
            <summary>
            Governs .Net collection serialization
            </summary>
        </member>
        <member name="F:Marten.CollectionStorage.Default">
            <summary>
            Use default serialization for collections according to the serializer
            being used
            </summary>
        </member>
        <member name="F:Marten.CollectionStorage.AsArray">
            <summary>
            Direct the underlying serializer to serialize collections as JSON arrays
            </summary>
        </member>
        <member name="T:Marten.ITenantOperations">
            <summary>
            Access to querying or registering updates for a separate tenant
            to a parent IDocumentSession
            </summary>
        </member>
        <member name="P:Marten.ITenantOperations.TenantId">
            <summary>
            The tenant id of this tenant operations
            </summary>
        </member>
        <member name="T:Marten.ITenantQueryOperations">
            <summary>
            Access to querying or registering updates for a separate tenant
            to a parent IDocumentSession
            </summary>
        </member>
        <member name="P:Marten.ITenantQueryOperations.TenantId">
            <summary>
            The tenant id of this tenant operations
            </summary>
        </member>
        <member name="T:Marten.Linq.FetchType">
            <summary>
            In basic terms, how is the IQueryable going to be executed?
            </summary>
        </member>
        <member name="F:Marten.Linq.FetchType.FetchOne">
            <summary>
            First/FirstOrDefault/Single/SingleOrDefault
            </summary>
        </member>
        <member name="F:Marten.Linq.FetchType.FetchMany">
            <summary>
            Any execution that returns an IEnumerable (ToArray()/ToList()/etc.)
            </summary>
        </member>
        <member name="F:Marten.Linq.FetchType.Count">
            <summary>
            Using IQueryable.Count()
            </summary>
        </member>
        <member name="F:Marten.Linq.FetchType.Any">
            <summary>
            Using IQueryable.Any()
            </summary>
        </member>
        <member name="P:Marten.Linq.Fields.DuplicatedField.DbType">
            <summary>
                Used to override the assigned DbType used by Npgsql when a parameter
                is used in a query against this column
            </summary>
        </member>
        <member name="P:Marten.Linq.Fields.FieldBase.JSONBLocator">
            <summary>
            Locate the data for this field as JSONB
            </summary>
        </member>
        <member name="T:Marten.Linq.Fields.IFieldMapping">
            <summary>
            Internal representation of queryable members within a Linq query
            </summary>
        </member>
        <member name="P:Marten.Linq.Fields.IField.TypedLocator">
            <summary>
            Postgresql locator that also casts the raw string data to the proper Postgresql type
            </summary>
        </member>
        <member name="P:Marten.Linq.Fields.IField.RawLocator">
            <summary>
            Postgresql locator that returns the raw string value within the JSONB document
            </summary>
        </member>
        <member name="M:Marten.Linq.Fields.IField.GetValueForCompiledQueryParameter(System.Linq.Expressions.Expression)">
            <summary>
            May "correct" the raw value as appropriate for the constant parameter value
            within a compiled query
            </summary>
            <param name="valueExpression"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.Linq.Fields.IField.FieldType">
            <summary>
            The .Net type of this IField
            </summary>
        </member>
        <member name="P:Marten.Linq.Fields.IField.JSONBLocator">
            <summary>
            Locate the data for this field as JSONB
            </summary>
        </member>
        <member name="T:Marten.Linq.Fields.IFieldSource">
            <summary>
            An extension point to "teach" Marten how to support new member types in the Linq support
            </summary>
        </member>
        <member name="T:Marten.Linq.Fields.SimpleDataField">
            <summary>
            Represents a literal field in a sub query that selects a simple or primitive type
            </summary>
        </member>
        <member name="T:Marten.Linq.Filters.ITenantWhereFragment">
            <summary>
            Marker interface to help Marten track whether or not a Linq
            query has some kind of tenant-aware filtering
            </summary>
        </member>
        <member name="T:Marten.Linq.Filters.SpecificTenantFilter">
            <summary>
            SQL WHERE fragment for a specific tenant
            </summary>
        </member>
        <member name="T:Marten.Linq.IQueryPlanning">
            <summary>
            To "help" out the compiled query planning, you may need to implement this interface
            to create meaningful, unique values for each query parameter. NOTE: a value for Take()
            and Skip() must be greater than zero for query planning to work!
            </summary>
        </member>
        <member name="T:Marten.Linq.ICompiledQuery`2">
            <summary>
            Used to express a query expression that when used will be cached by class type implementing this interface
            </summary>
            <typeparam name="TDoc">The document</typeparam>
            <typeparam name="TOut">The result type for a query</typeparam>
        </member>
        <member name="T:Marten.Linq.ICompiledListQuery`1">
            <summary>
            A *temporary* marker interface that for now is necessary to express enumerable result sets
            Once the concept of a result transformer is introduced we can remove the need for this extra interface
            </summary>
            <typeparam name="TDoc">The document</typeparam>
        </member>
        <member name="T:Marten.Linq.ICompiledListQuery`2">
            <summary>
            A temporary marker interface that for now is necessary to express enumerable result sets
            </summary>
            <typeparam name="TDoc">The document</typeparam>
            <typeparam name="TOut">The output type</typeparam>
        </member>
        <member name="T:Marten.Linq.ICompiledQuery`1">
            <summary>
            Used to express a query expression that when used will be cached by class type implementing this interface
            </summary>
            <typeparam name="TDoc">The document</typeparam>
        </member>
        <member name="M:Marten.Linq.IConfigureExplainExpressions.Analyze">
            <summary>
            Carry out the command and show actual run times and other statistics.
            </summary>
        </member>
        <member name="M:Marten.Linq.IConfigureExplainExpressions.Verbose">
            <summary>
            Display additional information regarding the plan. Specifically, include the output column list for each node in the plan tree, schema-qualify table and function names, always label variables in expressions with their range table alias, and always print the name of each trigger for which statistics are displayed.
            </summary>
        </member>
        <member name="M:Marten.Linq.IConfigureExplainExpressions.Costs">
            <summary>
            Include information on the estimated startup and total cost of each plan node, as well as the estimated number of rows and the estimated width of each row.
            </summary>
        </member>
        <member name="M:Marten.Linq.IConfigureExplainExpressions.Buffers">
            <summary>
            Include information on buffer usage. Specifically, include the number of shared blocks hit, read, dirtied, and written, the number of local blocks hit, read, dirtied, and written, and the number of temp blocks read and written.
            </summary>
        </member>
        <member name="M:Marten.Linq.IConfigureExplainExpressions.Timing">
            <summary>
            Include the actual startup time and time spent in the node in the output.
            </summary>
        </member>
        <member name="M:Marten.Linq.IMartenQueryable.Explain(Marten.Linq.FetchType,System.Action{Marten.Linq.IConfigureExplainExpressions})">
            <param name="configureExplain">Configure EXPLAIN options as documented in <see href="https://www.postgresql.org/docs/9.6/static/sql-explain.html">EXPLAIN documentation</see></param>
        </member>
        <member name="M:Marten.Linq.IMartenQueryable`1.Include``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Action{``0})">
            <summary>
            Also fetch related documents, and call the callback lambda for each
            related document
            </summary>
            <param name="idSource"></param>
            <param name="callback"></param>
            <typeparam name="TInclude"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.IMartenQueryable`1.Include``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Collections.Generic.IList{``0})">
            <summary>
            Also fetch related documents, and add the related documents to
            the supplied list
            </summary>
            <param name="idSource"></param>
            <param name="list"></param>
            <typeparam name="TInclude"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.IMartenQueryable`1.Include``2(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Collections.Generic.IDictionary{``1,``0})">
            <summary>
            Also fetch related documents, and add the related documents to
            the supplied dictionary organized by the identity of the related document
            </summary>
            <param name="idSource"></param>
            <param name="dictionary"></param>
            <typeparam name="TInclude"></typeparam>
            <typeparam name="TKey"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.IMartenQueryable`1.Stats(Marten.Linq.QueryStatistics@)">
            <summary>
            Retrieve the total number of persisted rows in the database that match this
            query. Useful for server side paging.
            </summary>
            <param name="stats"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.IMartenQueryable`1.ToAsyncEnumerable(System.Threading.CancellationToken)">
            <summary>
            Execute this query to an IAsyncEnumerable. This is valuable for reading
            and processing large result sets without having to keep the entire
            result set in memory
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Linq.IMethodCallMatcher">
            <summary>
            Extension point to Marten's Linq support to add custom MethodInfo handling
            in the query creation
            </summary>
        </member>
        <member name="T:Marten.Linq.Includes.IIncludeReader">
            <summary>
            Used internally to process Include() operations
            in the Linq support
            </summary>
        </member>
        <member name="T:Marten.Linq.Includes.Include">
            <summary>
            Used internally to process Include() operations
            in the Linq support
            </summary>
        </member>
        <member name="M:Marten.Linq.Includes.Include.ReaderToAction``1(Marten.Internal.IMartenSession,System.Action{``0})">
            <summary>
            Used internally to process Include() operations
            in the Linq support
            </summary>
        </member>
        <member name="M:Marten.Linq.Includes.Include.ReaderToList``1(Marten.Internal.IMartenSession,System.Collections.Generic.IList{``0})">
            <summary>
            Used internally to process Include() operations
            in the Linq support
            </summary>
        </member>
        <member name="M:Marten.Linq.Includes.Include.ReaderToDictionary``2(Marten.Internal.IMartenSession,System.Collections.Generic.IDictionary{``1,``0})">
            <summary>
            Used internally to process Include() operations
            in the Linq support
            </summary>
        </member>
        <member name="T:Marten.Linq.Includes.IncludeQueryHandler`1">
            <summary>
            Used internally to process Include() operations
            in the Linq support
            </summary>
        </member>
        <member name="M:Marten.Linq.LastModified.LastModifiedExtensions.ModifiedSince(System.Object,System.DateTimeOffset)">
            <summary>
            The search results should include documents modified since given time (&gt;)
            </summary>
            <param name="doc"></param>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.LastModified.LastModifiedExtensions.ModifiedBefore(System.Object,System.DateTimeOffset)">
            <summary>
            The search results should include documents modified before given time (&lt;)
            </summary>
            <param name="doc"></param>
            <param name="time"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Marten.Linq.MartenLinqQueryProvider.BuildLinqHandler(System.Linq.Expressions.Expression)" -->
        <member name="M:Marten.Linq.MatchesSql.MatchesSqlExtensions.MatchesSql(System.Object,Weasel.Postgresql.SqlGeneration.ISqlFragment)">
            <summary>
            The search results should match the specified where fragment.
            </summary>
            <param name="doc"></param>
            <param name="whereFragment"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.MatchesSql.MatchesSqlExtensions.MatchesSql(System.Object,System.String,System.Object[])">
            <summary>
            The search results should match the specified raw sql fragment.
            </summary>
            <param name="doc"></param>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.Parsing.IExpressionParser`1.Matches(`0)">
            <summary>
            Can this parser create a Sql where clause
            from part of a Linq expression
            </summary>
        </member>
        <member name="M:Marten.Linq.Parsing.IExpressionParser`1.Parse(Marten.Linq.Fields.IFieldMapping,Marten.ISerializer,`0)">
            <summary>
            Creates an ISqlFragment object that Marten
            uses to help construct the underlying Sql
            command
            </summary>
        </member>
        <member name="T:Marten.Linq.Parsing.IMethodCallParser">
            <summary>
            Models the Sql generation for a method call
            in a Linq query. For example, map an expression like Where(x => x.Property.StartsWith("prefix"))
            to part of a Sql WHERE clause
            </summary>
        </member>
        <member name="M:Marten.Linq.Parsing.IMethodCallParser.Matches(System.Linq.Expressions.MethodCallExpression)">
            <summary>
            Can this parser create a Sql where clause
            from part of a Linq expression that calls
            a method
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.Parsing.IMethodCallParser.Parse(Marten.Linq.Fields.IFieldMapping,Marten.ISerializer,System.Linq.Expressions.MethodCallExpression)">
            <summary>
            Creates an ISqlFragment object that Marten
            uses to help construct the underlying Sql
            command
            </summary>
            <param name="mapping"></param>
            <param name="serializer"></param>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Linq.Parsing.Methods.SimpleEqualsParser">
            <summary>
            Implement Equals for <see cref="T:System.Int32"/>, <see cref="T:System.Int64"/>, <see cref="T:System.Decimal"/>, <see cref="T:System.Guid"/>, <see cref="T:System.Boolean"/>, <see cref="T:System.DateTime"/>, <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <remarks>Equals(object) calls into <see cref="M:System.Convert.ChangeType(System.Object,System.Type)"/>. Equals(null) is converted to "is null" query.</remarks>
        </member>
        <member name="T:Marten.Linq.Parsing.Methods.SimpleNotEqualsParser">
            <summary>
            Implement !Equals for <see cref="T:System.Int32"/>, <see cref="T:System.Int64"/>, <see cref="T:System.Decimal"/>, <see cref="T:System.Guid"/>, <see cref="T:System.Boolean"/>, <see cref="T:System.DateTime"/>, <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <remarks>Equals(object) calls into <see cref="M:System.Convert.ChangeType(System.Object,System.Type)"/>. Equals(null) is converted to "is null" query.</remarks>
        </member>
        <member name="M:Marten.Linq.Parsing.Methods.StringComparisonParser.FormatValue(System.Reflection.MethodInfo,System.String)">
            <summary>
                Formats the string value as appropriate for the comparison.
            </summary>
            <param name="method"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.Parsing.Methods.StringComparisonParser.GetOperator(System.Linq.Expressions.MethodCallExpression)">
            <summary>
                Returns the operator to emit (e.g. LIKE/ILIKE).
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.Parsing.Methods.StringComparisonParser.GetLocator(Marten.Linq.Fields.IFieldMapping,System.Linq.Expressions.MethodCallExpression)">
            <summary>
                Returns a locator for the member being queried upon
            </summary>
            <param name="mapping"></param>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.Linq.QueryPlan.NodeType">
            <summary>
            The scan type to be used to retrieve the data (ie sequential, index).
            </summary>
        </member>
        <member name="P:Marten.Linq.QueryPlan.RelationName">
            <summary>
            The table name from which the 'select' was queried.
            </summary>
        </member>
        <member name="P:Marten.Linq.QueryPlan.Alias">
            <summary>
            The table alias that was used (if none was used, <see cref="P:Marten.Linq.QueryPlan.RelationName"/> is returned).
            </summary>
        </member>
        <member name="P:Marten.Linq.QueryPlan.StartupCost">
            <summary>
            The cost of initialising the query.
            (note that "cost" does not have a unit - it's an arbitrary value)
            </summary>
        </member>
        <member name="P:Marten.Linq.QueryPlan.TotalCost">
            <summary>
            The cost ofo performing the query.
            (note that "cost" does not have a unit - it's an arbitrary value)
            </summary>
        </member>
        <member name="P:Marten.Linq.QueryPlan.PlanRows">
            <summary>
            The estimated number of rows returned.
            </summary>
        </member>
        <member name="P:Marten.Linq.QueryPlan.PlanWidth">
            <summary>
            The storage size of the query returned fields.
            </summary>
        </member>
        <member name="P:Marten.Linq.QueryPlan.Command">
            <summary>
            The command executed by Marten
            </summary>
        </member>
        <member name="T:Marten.Linq.QueryStatistics">
            <summary>
            Used to supply the total number of rows in the database for server side
            paging scenarios
            </summary>
        </member>
        <member name="P:Marten.Linq.QueryStatistics.TotalResults">
            <summary>
            The total number of records in the database for this query
            </summary>
        </member>
        <member name="M:Marten.Linq.SoftDeletes.SoftDeletedExtensions.MaybeDeleted(System.Object)">
            <summary>
            The search results should include all documents, whether
            soft-deleted or not
            </summary>
            <typeparam name="T"></typeparam>
            <param name="doc"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.SoftDeletes.SoftDeletedExtensions.IsDeleted(System.Object)">
            <summary>
            The search results should only include soft-deleted
            documents
            </summary>
            <typeparam name="T"></typeparam>
            <param name="doc"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.SoftDeletes.SoftDeletedExtensions.DeletedSince(System.Object,System.DateTimeOffset)">
            <summary>
            The search results should include documents deleted since given time (&gt;)
            </summary>
            <param name="doc"></param>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.SoftDeletes.SoftDeletedExtensions.DeletedBefore(System.Object,System.DateTimeOffset)">
            <summary>
            The search results should include documents deleted before given time (&lt;)
            </summary>
            <param name="doc"></param>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Linq.SqlGeneration.ContainsIdSelectorStatement">
            <summary>
            Used as an intermediate CTE in sub-collection Contains(primitive) queries
            </summary>
        </member>
        <member name="T:Marten.Linq.SqlGeneration.CountComparisonStatement">
            <summary>
                Used when doing a Where(x => x.Children.Count(c => ....) > #) kind of filter
            </summary>
        </member>
        <member name="P:Marten.Linq.SqlGeneration.WhereCtIdInSubQuery.Not">
            <summary>
            Psych! Should there be a NOT in front of the sub query
            </summary>
        </member>
        <member name="T:Marten.Linq.SqlGeneration.IOperationFragment">
            <summary>
            Internal marker interface for organizing operations
            </summary>
        </member>
        <member name="T:Marten.Linq.SqlGeneration.ISelectClause">
            <summary>
            Internal interface for the Linq subsystem
            </summary>
        </member>
        <member name="T:Marten.Linq.SqlGeneration.Statement">
            <summary>
            Internal model used to generate SQL within Linq queries
            </summary>
        </member>
        <member name="P:Marten.Linq.SqlGeneration.Statement.ExportName">
            <summary>
                For CTEs
            </summary>
        </member>
        <member name="M:Marten.LinqExtensions.IsOneOf``1(``0,``0[])">
            <summary>
            Used for Linq queries to match an element to one of a list of values
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable"></param>
            <param name="matches"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.IsOneOf``1(``0,System.Collections.Generic.IList{``0})">
            <summary>
            Used for Linq queries to match an element to one of a list of values
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable"></param>
            <param name="matches"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.In``1(``0,``0[])">
            <summary>
            Used for Linq queries to match an element to one of a list of values
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable"></param>
            <param name="matches"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.In``1(``0,System.Collections.Generic.IList{``0})">
            <summary>
            Used for Linq queries to match an element to one of a list of values
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable"></param>
            <param name="matches"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.IsSupersetOf``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <summary>
            Used for Linq queries to determines whether an element is a superset of the specified collection
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.IsSubsetOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Used for Linq queries to determines whether an element is a subset of the specified collection
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.IsSubsetOf``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <summary>
            Used for Linq queries to determines whether an element is a subset of the specified collection
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.IsSupersetOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Used for Linq queries to determines whether an element is a superset of the specified collection
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.IsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Used for Linq queries to match on empty child collections
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.AnyTenant``1(``0)">
            <summary>
            Query across any and all tenants
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.TenantIsOneOf``1(``0,System.String[])">
            <summary>
            Query for the range of supplied tenants
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable"></param>
            <param name="tenantIds"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.Search``1(``0,System.String)">
            <summary>
            Performs a full text search against <typeparamref name="TDoc"/>
            </summary>
            <param name="searchTerm">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.LinqExtensions.Search``1(``0,System.String,System.String)">
            <summary>
            Performs a full text search against <typeparamref name="TDoc"/>
            </summary>
            <param name="searchTerm">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <param name="regConfig">The dictionary config passed to the 'to_tsquery' function, must match the config parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)"/></param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.LinqExtensions.PlainTextSearch``1(``0,System.String)">
            <summary>
            Performs a full text search against <typeparamref name="TDoc"/> using the 'plainto_tsquery' search function
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.LinqExtensions.PlainTextSearch``1(``0,System.String,System.String)">
            <summary>
            Performs a full text search against <typeparamref name="TDoc"/> using the 'plainto_tsquery' search function
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <param name="regConfig">The dictionary config passed to the 'to_tsquery' function, must match the config parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)"/></param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.LinqExtensions.PhraseSearch``1(``0,System.String)">
            <summary>
            Performs a full text search against <typeparamref name="TDoc"/> using the 'phraseto_tsquery' search function
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.LinqExtensions.PhraseSearch``1(``0,System.String,System.String)">
            <summary>
            Performs a full text search against <typeparamref name="TDoc"/> using the 'phraseto_tsquery' search function
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <param name="regConfig">The dictionary config passed to the 'to_tsquery' function, must match the config parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)"/></param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.LinqExtensions.WebStyleSearch``1(``0,System.String)">
            <summary>
            Performs a full text search against <typeparamref name="T"/> using the 'websearch_to_tsquery' search function
            </summary>
            <param name="searchTerm">The text to search for.  Uses an alternative syntax to the other search functions, similar to the one used by web search engines</param>
            <remarks>
            Supported from Postgres 11
            See: https://www.postgresql.org/docs/11/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.LinqExtensions.WebStyleSearch``1(``0,System.String,System.String)">
            <summary>
            Performs a full text search against <typeparamref name="T"/> using the 'websearch_to_tsquery' search function
            </summary>
            <param name="searchTerm">The text to search for.  Uses an alternative syntax to the other search functions, similar to the one used by web search engines</param>
            <param name="regConfig">The dictionary config passed to the 'websearch_to_tsquery' function, must match the config parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)"/></param>
            <remarks>
            Supported from Postgres 11
            See: https://www.postgresql.org/docs/11/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="P:Marten.IReadOnlyLinqParsing.FieldSources">
            <summary>
            Registered extensions to the Marten Linq support for special handling of
            specific .Net types
            </summary>
        </member>
        <member name="P:Marten.IReadOnlyLinqParsing.MethodCallParsers">
            <summary>
            Custom Linq expression parsers for your own methods
            </summary>
        </member>
        <member name="P:Marten.LinqParsing.FieldSources">
            <summary>
            Register extensions to the Marten Linq support for special handling of
            specific .Net types
            </summary>
        </member>
        <member name="F:Marten.LinqParsing.MethodCallParsers">
            <summary>
            Add custom Linq expression parsers for your own methods
            </summary>
        </member>
        <member name="T:Marten.MartenRegistry">
            <summary>
                Used to customize or optimize the storage and retrieval of document types
            </summary>
        </member>
        <member name="M:Marten.MartenRegistry.Include``1">
            <summary>
            Include the declarations from another MartenRegistry type
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Marten.MartenRegistry.Include(Marten.MartenRegistry)">
            <summary>
            Include the declarations from another MartenRegistry object
            </summary>
            <param name="registry"></param>
        </member>
        <member name="M:Marten.MartenRegistry.For``1">
            <summary>
                Configure a single document type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.PropertySearching(Marten.Schema.PropertySearching)">
            <summary>
                Specify the property searching mechanism for this document type. The default is
                JSON_Locator_Only
            </summary>
            <param name="searching"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.DocumentAlias(System.String)">
            <summary>
                Override the Postgresql schema alias for this document type in order
                to disambiguate similarly named document types. The default is just
                the document type name to lower case.
            </summary>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.Searchable(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String,System.Nullable{NpgsqlTypes.NpgsqlDbType},System.Action{Marten.Schema.DocumentIndex})">
            <summary>
                Marks a property or field on this document type as a searchable field that is also duplicated in the
                database document table
            </summary>
            <param name="expression"></param>
            <param name="pgType">Optional, overrides the Postgresql column type for the duplicated field</param>
            <param name="configure">
                Optional, allows you to customize the Postgresql database index configured for the duplicated
                field
            </param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.Duplicate(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String,System.Nullable{NpgsqlTypes.NpgsqlDbType},System.Action{Marten.Schema.DocumentIndex},System.Boolean)">
            <summary>
                Marks a property or field on this document type as a searchable field that is also duplicated in the
                database document table
            </summary>
            <param name="expression"></param>
            <param name="pgType">Optional, overrides the Postgresql column type for the duplicated field</param>
            <param name="configure">
                Optional, allows you to customize the Postgresql database index configured for the duplicated
                field
            </param>
            <param name="dbType">Optional, overrides the Npgsql DbType for any parameter usage of this property</param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.Index(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Action{Marten.Schema.ComputedIndex})">
            <summary>
                Creates a computed index on this data member within the JSON data storage
            </summary>
            <param name="expression"></param>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.Index(System.Collections.Generic.IReadOnlyCollection{System.Linq.Expressions.Expression{System.Func{`0,System.Object}}},System.Action{Marten.Schema.ComputedIndex})">
            <summary>
                Creates a computed index on this data member within the JSON data storage
            </summary>
            <param name="expressions"></param>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.UniqueIndex(System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
                Creates a unique index on this data member within the JSON data storage
            </summary>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.UniqueIndex(System.String,System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
                Creates a unique index on this data member within the JSON data storage
            </summary>
            <param name="indexName">Name of the index</param>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.UniqueIndex(Marten.Schema.UniqueIndexType,System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
                Creates a unique index on this data member within the JSON data storage
            </summary>
            <param name="indexType">Type of the index</param>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.UniqueIndex(Marten.Schema.UniqueIndexType,System.String,System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
                Creates a unique index on this data member within the JSON data storage
            </summary>
            <param name="indexType">Type of the index</param>
            <param name="indexName">Name of the index</param>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.UniqueIndex(Marten.Schema.UniqueIndexType,System.String,Marten.Schema.Indexing.Unique.TenancyScope,System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
                Creates a unique index on this data member within the JSON data storage
            </summary>
            <param name="indexType">Type of the index</param>
            <param name="indexTenancyStyle">Style of tenancy</param>
            <param name="indexName">Name of the index</param>
            <param name="tenancyScope">Whether the unique index applies on a per tenant basis</param>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.IndexLastModified(System.Action{Marten.Schema.DocumentIndex})">
            <summary>
                Creates an index on the predefined Last Modified column
            </summary>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.FullTextIndex(System.String,System.Action{Marten.Schema.FullTextIndex})">
            <summary>
            Create a full text index
            </summary>
            <param name="regConfig"></param>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.FullTextIndex(System.Action{Marten.Schema.FullTextIndex})">
            <summary>
            Create a full text index
            </summary>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.FullTextIndex(System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
            Create a full text index against designated fields on this document
            </summary>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.FullTextIndex(System.String,System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
            Create a full text index against designated fields on this document
            </summary>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.FullTextIndex(System.Action{Marten.Schema.FullTextIndex},System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
            Create a full text index against designated fields on this document
            </summary>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.ForeignKey``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Action{Marten.Schema.DocumentForeignKey},System.Action{Marten.Schema.DocumentIndex})">
            <summary>
                Add a foreign key reference to another document type
            </summary>
            <param name="expression"></param>
            <param name="foreignKeyConfiguration"></param>
            <param name="indexConfiguration"></param>
            <typeparam name="TReference"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.ForeignKey(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String,System.String,System.String,System.Action{Weasel.Postgresql.Tables.ForeignKey})">
            <summary>
            Create a foreign key against the designated member of the document
            </summary>
            <param name="expression"></param>
            <param name="schemaName"></param>
            <param name="tableName"></param>
            <param name="columnName"></param>
            <param name="foreignKeyConfiguration"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.HiloSettings(Marten.Schema.Identity.Sequences.HiloSettings)">
            <summary>
                Overrides the Hilo sequence increment and "maximum low" number for document types that
                use numeric id's and the Hilo Id assignment
            </summary>
            <param name="settings"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.DatabaseSchemaName(System.String)">
            <summary>
                Overrides the database schema name used to store the documents.
            </summary>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.IdStrategy(Marten.Schema.Identity.IIdGeneration)">
            <summary>
                Overrides the stragtegy used for id generation.
            </summary>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.Identity(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Explicitly choose the identity member for this document type
            </summary>
            <param name="member"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.GinIndexJsonData(System.Action{Marten.Schema.DocumentIndex})">
            <summary>
                Adds a Postgresql Gin index to the JSONB data column for this document type. Leads to faster
                querying, but does add overhead to storage and database writes
            </summary>
            <param name="configureIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.AddSubClass(System.Type,System.String)">
            <summary>
                Programmatically directs Marten to map this type to a hierarchy of types
            </summary>
            <param name="subclassType"></param>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.AddSubClassHierarchy(Marten.MappedType[])">
            <summary>
                Programmatically directs Marten to map all the subclasses of <cref name="T" /> to a hierarchy of types
            </summary>
            <param name="allSubclassTypes">
                All the subclass types of <cref name="T" /> that you wish to map.
                You can use either params of <see cref="T:System.Type" /> or <see cref="T:Marten.MappedType" /> or a mix, since Type can implicitly
                convert to MappedType (without an alias)
            </param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.AddSubClassHierarchy">
            <summary>
                Programmatically directs Marten to map all the subclasses of <cref name="T" /> to a hierarchy of types.
                <c>Unadvised in projects with many types.</c>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.AddSubClass``1(System.String)">
            <summary>
            Add a sub class type to this document type so that Marten will store that document in the parent
            table storage
            </summary>
            <param name="alias"></param>
            <typeparam name="TSubclass"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.UseOptimisticConcurrency(System.Boolean)">
            <summary>
                Directs Marten to use the optimistic versioning checks upon updates
                to this document type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.SoftDeleted">
            <summary>
                Directs Marten to apply "soft deletes" to this document type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.SoftDeletedWithIndex(System.Action{Marten.Schema.DocumentIndex})">
            <summary>
            Mark this document type as soft-deleted, with an index on the is_deleted column
            </summary>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.DdlTemplate(System.String)">
            <summary>
                Direct this document type's DDL to be created with the named template
            </summary>
            <param name="templateName"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.MultiTenanted">
            <summary>
                Marks just this document type as being stored with conjoined multi-tenancy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.UseIdentityKey">
            <summary>
                Opt into the identity key generation strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.Metadata(System.Action{Marten.MartenRegistry.DocumentMappingExpression{`0}.MetadataConfig})">
            <summary>
            Configure the metadata storage for only this document type
            </summary>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.Version">
            <summary>
            The current version of this document in the database
            </summary>
        </member>
        <member name="P:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.LastModified">
            <summary>
            Timestamp of the last time this document was modified
            </summary>
        </member>
        <member name="P:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.TenantId">
            <summary>
            The stored tenant id of this document
            </summary>
        </member>
        <member name="P:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.IsSoftDeleted">
            <summary>
            If soft-deleted, whether or not the document is marked as deleted
            </summary>
        </member>
        <member name="P:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.SoftDeletedAt">
            <summary>
            If soft-deleted, the time at which the document was marked as deleted
            </summary>
        </member>
        <member name="P:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.DocumentType">
            <summary>
            If the document is part of a type hierarchy, this designates
            Marten's internal name for the sub type
            </summary>
        </member>
        <member name="P:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.DotNetType">
            <summary>
            The full name of the .Net type that was persisted
            </summary>
        </member>
        <member name="P:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.CorrelationId">
            <summary>
            Optional metadata describing the correlation id for a
            unit of work
            </summary>
        </member>
        <member name="P:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.CausationId">
            <summary>
            Optional metadata describing the correlation id for a
            unit of work
            </summary>
        </member>
        <member name="P:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.LastModifiedBy">
            <summary>
            Optional metadata describing the user name or
            process name for this unit of work
            </summary>
        </member>
        <member name="P:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.Headers">
            <summary>
            Optional, user defined headers
            </summary>
        </member>
        <member name="P:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.Column`1.Enabled">
            <summary>
                Is the metadata field enabled. Note that this can not
                be overridden in some cases like the "version" column
                when a document uses optimistic versioning
            </summary>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.Column`1.MapTo(System.Linq.Expressions.Expression{System.Func{`0,`1}})">
            <summary>
                Map this metadata information to the designated Field or Property
                on the document type. This will also enable the tracking column
            in the underlying database table
            </summary>
            <param name="memberExpression"></param>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.DisableInformationalFields">
            <summary>
            Turn off the informational metadata columns
            in storage like the last modified, version, and
            dot net type for leaner storage
            </summary>
        </member>
        <member name="T:Marten.MappedType">
            <summary>
            Configures hierarchical type mapping to its parent
            </summary>
        </member>
        <member name="P:Marten.MappedType.Type">
            <summary>
            The .Net Type
            </summary>
        </member>
        <member name="P:Marten.MappedType.Alias">
            <summary>
            String alias that will be used to persist or load the documents
            from the underlying database
            </summary>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.AddMarten(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.String)">
            <summary>
            Add Marten IDocumentStore, IDocumentSession, and IQuerySession service registrations
            to your application with the given Postgresql connection string and Marten
            defaults
            </summary>
            <param name="services"></param>
            <param name="connectionString">The connection string to your application's Postgresql database</param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.AddMarten(Microsoft.Extensions.DependencyInjection.IServiceCollection,Marten.StoreOptions)">
            <summary>
            Add Marten IDocumentStore, IDocumentSession, and IQuerySession service registrations
            to your application using the configured StoreOptions
            </summary>
            <param name="services"></param>
            <param name="options">The Marten configuration for this application</param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.AddMarten(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Func{System.IServiceProvider,Marten.StoreOptions})">
            <summary>
            Add Marten IDocumentStore, IDocumentSession, and IQuerySession service registrations
            to your application by configuring a StoreOptions using services in your DI container
            </summary>
            <param name="optionSource">Func that will build out a StoreOptions with the applications IServiceProvider as the input</param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.AddMarten(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{Marten.StoreOptions})">
            <summary>
            Add Marten IDocumentStore, IDocumentSession, and IQuerySession service registrations
            to your application using the configured StoreOptions
            </summary>
            <param name="services"></param>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenConfigurationExpression.BuildSessionsWith``1(Microsoft.Extensions.DependencyInjection.ServiceLifetime)">
            <summary>
            Use an alternative strategy / configuration for opening IDocumentSession or IQuerySession
            objects in the application with a custom ISessionFactory type registered as a singleton
            </summary>
            <param name="lifetime">IoC service lifetime for the session factory. Default is Singleton, but use Scoped if you need to reference per-scope services</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="P:Marten.MartenServiceCollectionExtensions.MartenConfigurationExpression.Services">
            <summary>
            Gets the IServiceCollection
            </summary>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenConfigurationExpression.UseLightweightSessions">
            <summary>
            Use lightweight sessions by default for the injected IDocumentSession objects. Equivalent to IDocumentStore.LightweightSession();
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenConfigurationExpression.InitializeStore">
            <summary>
            Eagerly build the application's DocumentStore during application
            bootstrapping rather than waiting for the first usage of IDocumentStore
            at runtime.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Marten.ISessionFactory">
            <summary>
            Pluggable strategy for customizing how IDocumentSession / IQuerySession
            objects are created within an application.
            </summary>
        </member>
        <member name="M:Marten.ISessionFactory.QuerySession">
            <summary>
            Build new instances of IQuerySession on demand
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.ISessionFactory.OpenSession">
            <summary>
            Build new instances of IDocumentSession on demand
            </summary>
            <returns></returns>
        </member>
        <member name="T:Marten.Metadata.ISoftDeleted">
            <summary>
            Optionally implement this interface on your Marten document
            types to opt into "soft delete" mechanics with the deletion
            information tracked directly on the documents
            </summary>
        </member>
        <member name="P:Marten.Metadata.ISoftDeleted.Deleted">
            <summary>
            Has Marten marked this document as soft deleted
            </summary>
        </member>
        <member name="P:Marten.Metadata.ISoftDeleted.DeletedAt">
            <summary>
            When was this document marked as deleted by Marten
            </summary>
        </member>
        <member name="T:Marten.Metadata.ITenanted">
            <summary>
            Optionally implement this interface on your Marten document
            types to opt into conjoined tenancy and track the tenant id
            on the document itself
            </summary>
        </member>
        <member name="T:Marten.Metadata.ITracked">
            <summary>
            Optionally implement this interface to add correlation
            tracking to your Marten document type with the tracking
            information available on the documents themselves
            </summary>
        </member>
        <member name="P:Marten.Metadata.ITracked.CorrelationId">
            <summary>
            Metadata describing the correlation id for the
            last system activity to edit this document
            </summary>
        </member>
        <member name="P:Marten.Metadata.ITracked.CausationId">
            <summary>
            Metadata describing the causation id for the
            last system activity to edit this document
            </summary>
        </member>
        <member name="P:Marten.Metadata.ITracked.LastModifiedBy">
            <summary>
            Metadata describing the user who last modified
            this document
            </summary>
        </member>
        <member name="T:Marten.Metadata.IVersioned">
            <summary>
            Optionally implement this interface on your Marten document
            types to opt into optimistic concurrency with the version
            being tracked on the Version property
            </summary>
        </member>
        <member name="P:Marten.Metadata.IVersioned.Version">
            <summary>
            Marten's version for this document
            </summary>
        </member>
        <member name="T:Marten.NulloRetryPolicy">
            <summary>
            No-op implementation of IRetryPolicy
            </summary>
        </member>
        <member name="T:Marten.Pagination.IPagedList`1">
            <summary>
            Interface for paged list
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.Item(System.Int32)">
            <summary>
            Return the paged query result
            </summary>
            <param name="index">Index to fetch item from paged query result</param>
            <returns>/returns item from paged query result</returns>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.Count">
            <summary>
            Return the number of records in the paged query result
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.PageNumber">
            <summary>
            Gets current page number
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.PageSize">
            <summary>
            Gets page size
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.PageCount">
            <summary>
            Gets number of pages
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.TotalItemCount">
            <summary>
            Gets the total number records
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.HasPreviousPage">
            <summary>
            Gets a value indicating whether there is a previous page
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.HasNextPage">
            <summary>
            Gets a value indicating whether there is next page
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.IsFirstPage">
            <summary>
            Gets a value indicating whether the current page is first page
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.IsLastPage">
            <summary>
            Gets a value indicating whether the current page is last page
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.FirstItemOnPage">
            <summary>
            Gets one-based index of first item in current page
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.LastItemOnPage">
            <summary>
            Gets one-based index of last item in current page
            </summary>
        </member>
        <member name="T:Marten.Pagination.PagedList`1">
            <summary>
            Class to return The async paged list from a paged query.
            </summary>
            <typeparam name="T">Document Type</typeparam>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.Item(System.Int32)">
            <summary>
            Return the paged query result
            </summary>
            <param name="index">Index to fetch item from paged query result</param>
            <returns>/returns item from paged query result</returns>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.Count">
            <summary>
            Return the number of records in the paged query result
            </summary>
        </member>
        <member name="M:Marten.Pagination.PagedList`1.GetEnumerator">
            <summary>
            Generic Enumerator
            </summary>
            <returns>Generic Enumerator of paged query result</returns>
        </member>
        <member name="M:Marten.Pagination.PagedList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Enumerator
            </summary>
            <returns>Enumerator of paged query result</returns>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.PageNumber">
            <summary>
            Gets current page number
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.PageSize">
            <summary>
            Gets page size
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.PageCount">
            <summary>
            Gets number of pages
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.TotalItemCount">
            <summary>
            Gets the total number records
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.HasPreviousPage">
            <summary>
            Gets a value indicating whether there is a previous page
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.HasNextPage">
            <summary>
            Gets a value indicating whether there is next page
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.IsFirstPage">
            <summary>
            Gets a value indicating whether the current page is first page
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.IsLastPage">
            <summary>
            Gets a value indicating whether the current page is last page
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.FirstItemOnPage">
            <summary>
            Gets one-based index of first item in current page
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.LastItemOnPage">
            <summary>
            Gets one-based index of last item in current page
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Marten.Pagination.PagedList`1.Create(System.Linq.IQueryable{`0},System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Marten.Pagination.PagedList`1.CreateAsync(System.Linq.IQueryable{`0},System.Int32,System.Int32,System.Threading.CancellationToken)" -->
        <member name="M:Marten.Pagination.PagedList`1.Init(System.Linq.IQueryable{`0},System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Marten.Pagination.PagedList`1" /> class.
            </summary>
            <param name="queryable">Query for which data has to be fetched</param>
            <param name="pageSize">Page size</param>
            <param name="totalItemCount">Total count of all records</param>
        </member>
        <member name="M:Marten.Pagination.PagedList`1.InitAsync(System.Linq.IQueryable{`0},System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Initializes a new instance of the <see cref="T:Marten.Pagination.PagedList`1" /> class.
            </summary>
            <param name="queryable">Query for which data has to be fetched</param>
            <param name="pageSize">Page size</param>
            <param name="totalItemCount">Total count of all records</param>
        </member>
        <member name="T:Marten.Pagination.PagedListQueryableExtensions">
            <summary>
            Extension methods on <see cref="T:Marten.Linq.IMartenQueryable`1"/> for performing paged queries
            </summary>
        </member>
        <member name="M:Marten.Pagination.PagedListQueryableExtensions.ToPagedList``1(System.Linq.IQueryable{``0},System.Int32,System.Int32)">
            <summary>
            Extension method to return a paged results
            </summary>
            <typeparam name="T">Document Type</typeparam>
            <param name="queryable">Extension point on <see cref="T:System.Linq.IQueryable`1"/></param>
            <param name="pageNumber">one based page number</param>
            <param name="pageSize">Page size</param>
            <returns>return paged result</returns>
        </member>
        <member name="M:Marten.Pagination.PagedListQueryableExtensions.ToPagedListAsync``1(System.Linq.IQueryable{``0},System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Async Extension method to return a paged results
            </summary>
            <typeparam name="T">Document Type</typeparam>
            <param name="queryable">Extension point on <see cref="T:System.Linq.IQueryable`1"/></param>
            <param name="pageNumber">One based page number</param>
            <param name="pageSize">Page size</param>
            <param name="token">Cancellation token</param>
            <returns>return paged result</returns>
        </member>
        <member name="M:Marten.QueryableExtensions.Explain``1(System.Linq.IQueryable{``0},System.Action{Marten.Linq.IConfigureExplainExpressions})">
            <summary>
            Fetch the Postgresql QueryPlan for the Linq query
            </summary>
            <param name="queryable"></param>
            <param name="configureExplain"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.QueryableExtensions.ToListAsync``1(System.Linq.IQueryable{``0},System.Threading.CancellationToken)">
            <summary>
            Fetch results asynchronously to a read only list
            </summary>
            <param name="queryable"></param>
            <param name="token"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.QueryableExtensions.ToCommand``1(System.Linq.IQueryable{``0},Marten.Linq.FetchType)">
            <summary>
            Builds the database command that would be used to execute this Linq query
            </summary>
            <param name="queryable"></param>
            <param name="fetchType"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Marten.QueryableExtensions.Include``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Action{``1})">
            <summary>
            Fetch a related document of type TInclude when executing the Linq query and
            call the supplied callback for each result
            </summary>
            <param name="queryable"></param>
            <param name="idSource"></param>
            <param name="callback"></param>
            <typeparam name="T"></typeparam>
            <typeparam name="TInclude"></typeparam>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Marten.QueryableExtensions.Include``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Collections.Generic.IList{``1})" -->
        <member name="M:Marten.QueryableExtensions.Include``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Collections.Generic.IDictionary{``1,``2})">
            <summary>
            Fetch related documents when executing the Linq query and store the related documents
            into the supplied dictionary
            </summary>
            <param name="queryable"></param>
            <param name="idSource"></param>
            <param name="dictionary"></param>
            <typeparam name="T"></typeparam>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TInclude"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.QueryableExtensions.ToAsyncEnumerable``1(System.Linq.IQueryable{``0},System.Threading.CancellationToken)">
            <summary>
            Execute this query to an IAsyncEnumerable. This is valuable for reading
            and processing large result sets without having to keep the entire
            result set in memory
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.QueryableExtensions.StreamJsonArray``1(System.Linq.IQueryable{``0},System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Write the raw persisted JSON for the Linq query directly to the destination stream
            </summary>
            <param name="destination"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.QuerySessionExtensions.Query(Marten.IQuerySession,System.Type,System.String,System.Object[])">
            <summary>
            Query by a user-supplied .Net document type and user-supplied SQL
            </summary>
            <param name="session"></param>
            <param name="type"></param>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.QuerySessionExtensions.QueryAsync(Marten.IQuerySession,System.Type,System.String,System.Threading.CancellationToken,System.Object[])">
            <summary>
            Query by a user-supplied .Net document type and user-supplied SQL
            </summary>
            <param name="session"></param>
            <param name="type"></param>
            <param name="sql"></param>
            <param name="token"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.Count">
            <summary>
            Return a count of all the documents of type "T"
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.Count(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Return a count of all the documents of type "T" that match the query
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.Any">
            <summary>
            Where for the existence of any documents of type "T" matching the query
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.Any(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Where for the existence of any documents of type "T"
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.First(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Find the first document of type "T" matching this query. Will throw an exception if there are no matching documents
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.FirstOrDefault">
            <summary>
            Find the first document of type "T" that matches the query. Will return null if no documents match.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.Single">
            <summary>
            Returns the single document of type "T" matching this query. Will
            throw an exception if the results are null or contain more than one
            document
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.Single(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Returns the single document of type "T" matching this query. Will
            throw an exception if the results are null or contain more than one
            document
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.SingleOrDefault">
            <summary>
            Returns the single document of type "T" matching this query or null. Will
            throw an exception if the results contain more than one
            document
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.SingleOrDefault(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Returns the single document of type "T" matching this query or null. Will
            throw an exception if the results contain more than one
            document
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchEvents.Load(System.Guid)">
            <summary>
            Load a single event with all of its metadata
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchEvents.FetchStreamState(System.Guid)">
            <summary>
            Load the high level metadata about a single event stream
            </summary>
            <param name="streamId"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchEvents.FetchStream(System.Guid,System.Int64,System.Nullable{System.DateTime},System.Int64)">
            <summary>
            Fetch all the events for a single event stream
            </summary>
            <param name="streamId"></param>
            <param name="version">If set, queries for events up to and including this version</param>
            <param name="timestamp">If set, queries for events captured on or before this timestamp</param>
            <param name="fromVersion">If set, queries for events on or from this version</param>
            <returns></returns>
        </member>
        <member name="P:Marten.Services.BatchQuerying.IBatchedQuery.Events">
            <summary>
            Access to event store specific query mechanisms
            </summary>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.Load``1(System.String)">
            <summary>
            Load a single document of Type "T" by id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.Load``1(System.Int32)">
            <summary>
            Load a single document of Type "T" by id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.Load``1(System.Int64)">
            <summary>
            Load a single document of Type "T" by id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.Load``1(System.Guid)">
            <summary>
            Load a single document of Type "T" by id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.LoadMany``1">
            <summary>
            Load a one or more documents of Type "T" by id's
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.Query``1(System.String,System.Object[])">
            <summary>
            Execute a user provided query against "T"
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.Execute(System.Threading.CancellationToken)">
            <summary>
            Execute this batched query
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.Query``1">
            <summary>
            Where for documents of type "T" by Linq expression
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.Query``2(Marten.Linq.ICompiledQuery{``0,``1})">
            <summary>
            Execute a compiled query as part of the batch query
            </summary>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.ExecuteSynchronously">
            <summary>
            Force the batched query to execute synchronously
            </summary>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQueryable`1.Stats(Marten.Linq.QueryStatistics@)">
            <summary>
            Retrieve the total number of persisted rows in the database that match this
            query. Useful for server side paging.
            </summary>
            <param name="stats"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQueryable`1.Include``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Action{``0})">
            <summary>
            Also fetch related documents, and call the callback lambda for each
            related document
            </summary>
            <param name="idSource"></param>
            <param name="callback"></param>
            <typeparam name="TInclude"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQueryable`1.Include``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Collections.Generic.IList{``0})">
            <summary>
            Also fetch related documents, and add the related documents to
            the supplied list
            </summary>
            <param name="idSource"></param>
            <param name="list"></param>
            <typeparam name="TInclude"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQueryable`1.Include``2(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Collections.Generic.IDictionary{``1,``0})">
            <summary>
            Also fetch related documents, and add the related documents to
            the supplied dictionary organized by the identity of the related document
            </summary>
            <param name="idSource"></param>
            <param name="dictionary"></param>
            <typeparam name="TInclude"></typeparam>
            <typeparam name="TKey"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchLoadByKeys`1.ById``1(``0[])">
            <summary>
            Load multiple documents by an array of keys
            </summary>
            <param name="keys"></param>
            <typeparam name="TKey"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchLoadByKeys`1.ByIdList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Load multiple documents by a list of keys
            </summary>
            <param name="keys"></param>
            <typeparam name="TKey"></typeparam>
            <returns></returns>
        </member>
        <member name="F:Marten.Services.CommandRunnerMode.External">
            <summary>
            Implies that some other process is controlling the transaction boundaries
            </summary>
        </member>
        <member name="M:Marten.Services.Diagnostics.PreviewCommand``2(Marten.Linq.ICompiledQuery{``0,``1})">
            <summary>
            Preview the database command that will be executed for this compiled query
            object
            </summary>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.Diagnostics.ExplainPlan``2(Marten.Linq.ICompiledQuery{``0,``1})">
            <summary>
            Find the Postgresql EXPLAIN PLAN for this compiled query
            </summary>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.Diagnostics.GetPostgresVersion">
            <summary>
            Method to fetch Postgres server version
            </summary>
            <returns>Returns version</returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.Deletions">
            <summary>
            All of the pending deletions that will be processed
            when this session is committed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.DeletionsFor``1">
            <summary>
            All the pending deletions of documents of type T that will be processed
            when this session is committed
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.DeletionsFor(System.Type)">
            <summary>
            All the pending deletions of documents of type documentType that will be processed
            when this session is committed
            </summary>
            <param name="documentType"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.Updates">
            <summary>
            All the documents that will be updated when this session is committed
            This is inclusive of both Upsert and Updates
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.Inserts">
            <summary>
            All of the documents that will be inserted when this session is committed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.UpdatesFor``1">
            <summary>
            All the documents of type T that will be updated when this session is committed.
            This is inclusive of both Upsert and Updates
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.InsertsFor``1">
            <summary>
            All the documents of type T that will be inserted when this session is committed
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.AllChangedFor``1">
            <summary>
            All of the documents of type T that will be inserted or updated when this session
            is committed
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.Streams">
            <summary>
            All of the pending events for the event store in this unit of work
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.Operations">
            <summary>
            All the storage operations that will be executed when this session is committed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.OperationsFor``1">
            <summary>
            All the storage operations that will be executed for documents of type T when this
            session is committed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.OperationsFor(System.Type)">
            <summary>
            All the storage operations that will be executed for documents of type T when this
            session is committed
            </summary>
            <param name="documentType"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Services.Json.JsonNetCollectionToArrayJsonConverter">
            <summary>
            Serialize collection type property to JSON array using a custom Newtonsoft.Json JsonConverter
            Note that without using custom `JsonConverter`, `Newtonsoft.Json` stores it as $type and $value.
            Or you may need to resort to `Newtonsoft.Json.TypeNameHandling.None` which has its own side-effects
            </summary>
        </member>
        <member name="T:Marten.Services.Json.SystemObjectNewtonsoftCompatibleConverter">
            <summary>
            Taken from: https://github.com/dotnet/runtime/blob/3e4a06c0e90e65c0ad514d8e2a9f93cb584d775a/src/libraries/System.Text.Json/tests/Serialization/CustomConverterTests.Object.cs#L267
            A converter that converts System.Object similar to Newtonsoft's JSON.Net.
            Only primitives are the same; arrays and objects do not result in the same types.
            </summary>
        </member>
        <member name="T:Marten.Services.Json.JsonSerializerExtensions">
            <summary>
            This class is intended as a sample for supporting the <see langword="dynamic"/> feature.
            </summary>
            <remarks>
            It requires a reference to the "System.Linq.Expressions" assembly.
            </remarks>
        </member>
        <member name="M:Marten.Services.Json.JsonSerializerExtensions.EnableDynamicTypes(System.Text.Json.JsonSerializerOptions)">
            <summary>
            Enable support for the <see langword="dynamic"/> feature.
            Changes the default handling for types specified as <see cref="T:System.Object"/> from deserializing as
            <see cref="T:System.Text.Json.JsonElement"/> to instead deserializing as the one of the
            <see cref="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicType"/>-derived types including:
            <see cref="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicObject"/>,
            <see cref="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicArray"/>,
            <see cref="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicString"/>,
            <see cref="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicNumber"/> and
            <see cref="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicBoolean"/>.
            </summary>
            <remarks>
            When deserializing <see cref="F:System.Text.Json.JsonTokenType.StartObject"/>, <see cref="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicObject"/>
            is returned which implements <see cref="!:System.Collections.IDictionary&lt;string, object&gt;"/>.
            When deserializing <see cref="F:System.Text.Json.JsonTokenType.StartArray"/>, <see cref="!:System.Collections.IList&lt;object&gt;"/>
            is returned which implements <see cref="!:System.Collections.IList&lt;object&gt;"/>.
            When deserializing <see cref="F:System.Text.Json.JsonTokenType.String"/>, <see cref="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicString"/>
            is returned and supports an implicit cast to <see cref="T:System.String"/>.
            An explicit cast or assignment to other types, such as <see cref="!:System.Text.Json.JsonTokenType.DateTime"/>,
            is supported provided there is a custom converter for that Type.
            When deserializing <see cref="F:System.Text.Json.JsonTokenType.Number"/>, <see cref="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicNumber"/> is returned.
            An explicit cast or assignment is required to the appropriate number type, such as <see cref="T:System.Decimal"/> or <see cref="T:System.Int64"/>.
            When deserializing <see cref="F:System.Text.Json.JsonTokenType.True"/> and <see cref="F:System.Text.Json.JsonTokenType.False"/>,
            <see cref="!:JsonDynamicBool"/> is returned and supports an implicit cast to <see cref="T:System.Boolean"/>.
            An explicit cast or assignment to other types is supported provided there is a custom converter for that type.
            When deserializing <see cref="F:System.Text.Json.JsonTokenType.Null"/>, <see langword="null"/> is returned.
            </remarks>
        </member>
        <member name="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicType">
            <summary>
            The base class for all dynamic types supported by the serializer.
            </summary>
        </member>
        <member name="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicString">
            <summary>
            Supports dynamic strings.
            </summary>
        </member>
        <member name="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicNumber">
            <summary>
            Supports dynamic numbers.
            </summary>
        </member>
        <member name="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicBoolean">
            <summary>
            Supports dynamic booleans.
            </summary>
        </member>
        <member name="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicObject">
            <summary>
            Supports dynamic objects.
            </summary>
        </member>
        <member name="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicArray">
            <summary>
            Supports dynamic arrays.
            </summary>
        </member>
        <member name="T:Marten.Services.Json.JsonSerializerExtensions.DynamicObjectConverter">
            <summary>
            Supports deserialization of all <see cref="T:System.Object"/>-declared types, supporting <see langword="dynamic"/>.
            supports serialization of all <see cref="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicType"/>-derived types.
            </summary>
        </member>
        <member name="T:Marten.Services.JsonNetSerializer">
            <summary>
            Serialization with Newtonsoft.Json
            </summary>
        </member>
        <member name="M:Marten.Services.JsonNetSerializer.Customize(System.Action{Newtonsoft.Json.JsonSerializer})">
            <summary>
            Customize the inner Newtonsoft formatter.
            </summary>
            <param name="configure"></param>
        </member>
        <member name="P:Marten.Services.JsonNetSerializer.EnumStorage">
            <summary>
            Specify whether .Net Enum values should be stored as integers or strings
            within the Json document. Default is AsInteger.
            </summary>
        </member>
        <member name="P:Marten.Services.JsonNetSerializer.Casing">
            <summary>
            Specify whether properties in the JSON document should use Camel or Pascal casing.
            </summary>
        </member>
        <member name="P:Marten.Services.JsonNetSerializer.CollectionStorage">
            <summary>
            Specify whether collections should be stored as json arrays (without type names)
            </summary>
        </member>
        <member name="P:Marten.Services.JsonNetSerializer.NonPublicMembersStorage">
            <summary>
            Specify whether non public members should be used during deserialization
            </summary>
        </member>
        <member name="T:Marten.Services.NoDataReturnedCall">
            <summary>
            Marker interface telling Marten not
            to advance the results for callbacks
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.Tracking">
            <summary>
            Default to DocumentTracking.IdentityOnly
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.Timeout">
            <summary>
            If not specified, sessions default to Npgsql command timeout (30 seconds)
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.IsolationLevel">
            <summary>
            Default to IsolationLevel.ReadCommitted
            </summary>
        </member>
        <member name="F:Marten.Services.SessionOptions.Listeners">
            <summary>
                Add, remove, or reorder local session listeners
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.TenantId">
            <summary>
            Override the tenant id for the requested session
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.ConcurrencyChecks">
            <summary>
            Use to enable or disable optimistic concurrency for just this session
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.Connection">
            <summary>
            Optional mechanism to open a session with an existing connection
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.Transaction">
            <summary>
            Optional mechanism to open a session with an existing transaction
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.OwnsTransactionLifecycle">
            <summary>
            Default is true. If false, Marten will issue commands on IDocumentSession.SaveChanges/SaveChangesAsync,
            but will **not** commit the transaction
            </summary>
        </member>
        <member name="M:Marten.Services.SessionOptions.ForTransaction(Npgsql.NpgsqlTransaction)">
            <summary>
            Enlist in the native Npgsql transaction and direct the session
            *not* to own the transactional lifecycle
            </summary>
            <param name="transaction"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.Services.SessionOptions.EnlistInAmbientTransactionScope">
            <summary>
            Enlist the session in the current, ambient transaction scope
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.DotNetTransaction">
            <summary>
            Enlist the session in this transaction
            </summary>
        </member>
        <member name="M:Marten.Services.SessionOptions.ForCurrentTransaction">
            <summary>
            Open a session that enlists in the current, ambient TransactionScope
            </summary>
            <returns></returns>
        </member>
        <member name="F:Marten.Services.ConcurrencyChecks.Enabled">
            <summary>
            Optimistic concurrency checks are enforced (Default)
            </summary>
        </member>
        <member name="F:Marten.Services.ConcurrencyChecks.Disabled">
            <summary>
            Optimistic concurrency checks are disabled for this session
            </summary>
        </member>
        <member name="T:Marten.Services.SystemTextJsonSerializer">
            <summary>
            Serializer based on System.Text.Json
            </summary>
        </member>
        <member name="M:Marten.Services.SystemTextJsonSerializer.Customize(System.Action{System.Text.Json.JsonSerializerOptions})">
            <summary>
            Customize the inner System.Text.Json formatter.
            </summary>
            <param name="configure"></param>
        </member>
        <member name="P:Marten.Services.SystemTextJsonSerializer.EnumStorage">
            <inheritdoc />
        </member>
        <member name="P:Marten.Services.SystemTextJsonSerializer.Casing">
            <inheritdoc />
        </member>
        <member name="T:Marten.Services.VersionTracker">
            <summary>
            Used internally by Marten to track document versions
            </summary>
        </member>
        <member name="T:Marten.Storage.IFeatureSchema">
            <summary>
            Defines the database objects for a named feature within your
            Marten application
            </summary>
        </member>
        <member name="M:Marten.Storage.IFeatureSchema.DependentTypes">
            <summary>
            Any document or feature types that this feature depends on. Used
            to intelligently order the creation and scripting of database
            schema objects
            </summary>
            <returns></returns>
        </member>
        <member name="P:Marten.Storage.IFeatureSchema.Objects">
            <summary>
            All the schema objects in this feature
            </summary>
        </member>
        <member name="P:Marten.Storage.IFeatureSchema.StorageType">
            <summary>
            Identifier by type for this feature. Used along with the DependentTypes()
            collection to control the proper ordering of object creation or scripting
            </summary>
        </member>
        <member name="P:Marten.Storage.IFeatureSchema.Identifier">
            <summary>
            Really just the filename when the SQL is exported
            </summary>
        </member>
        <member name="M:Marten.Storage.IFeatureSchema.WritePermissions(Weasel.Postgresql.DdlRules,System.IO.TextWriter)">
            <summary>
            Write any permission SQL when this feature is exported to a SQL
            file
            </summary>
            <param name="rules"></param>
            <param name="writer"></param>
        </member>
        <member name="T:Marten.Storage.FeatureSchemaBase">
            <summary>
            Base class for easier creation of custom IFeatureSchema objects
            </summary>
        </member>
        <member name="M:Marten.Storage.ITenantStorage.ResetSchemaExistenceChecks">
            <summary>
                Directs Marten to disregard any previous schema checks. Useful
                if you change the underlying schema without shutting down the document store
            </summary>
        </member>
        <member name="M:Marten.Storage.ITenantStorage.EnsureStorageExists(System.Type)">
            <summary>
                Ensures that the IDocumentStorage object for a document type is ready
                and also attempts to update the database schema for any detected changes
            </summary>
            <param name="documentType"></param>
        </member>
        <member name="M:Marten.Storage.ITenantStorage.EnsureStorageExistsAsync(System.Type,System.Threading.CancellationToken)">
            <summary>
                Ensures that the IDocumentStorage object for a document type is ready
                and also attempts to update the database schema for any detected changes
            </summary>
            <param name="featureType"></param>
            <param name="??????"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.ITenantStorage.FindFeature(System.Type)">
            <summary>
            Find the feature schema object for the designated storageType
            </summary>
            <param name="storageType"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.Storage.ITenant.Sequences">
            <summary>
                Used to create new Hilo sequences
            </summary>
        </member>
        <member name="M:Marten.Storage.ITenant.StorageFor``1">
            <summary>
                Retrieves or generates the active IDocumentStorage object
                for the given document type
            </summary>
            <param name="documentType"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.ITenant.OpenConnection(Marten.Services.CommandRunnerMode,System.Data.IsolationLevel,System.Nullable{System.Int32})">
            <summary>
                Directly open a managed connection to the underlying Postgresql database
            </summary>
            <param name="mode"></param>
            <param name="isolationLevel"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.ITenant.ResetHiloSequenceFloor``1(System.Int64)">
            <summary>
                Set the minimum sequence number for a Hilo sequence for a specific document type
                to the specified floor. Useful for migrating data between databases
            </summary>
            <typeparam name="T"></typeparam>
            <param name="floor"></param>
        </member>
        <member name="M:Marten.Storage.ITenant.CreateConnection">
            <summary>
                Fetch a connection to the tenant database
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.ITenant.SchemaTables">
            <summary>
                Fetches a list of all of the Marten generated tables
                in the database
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.ITenant.DocumentTables">
            <summary>
                Fetches a list of the Marten document tables
                in the database
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.ITenant.Functions">
            <summary>
                Fetches a list of functions generated by Marten
                in the database
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.ITenant.DefinitionForFunction(Weasel.Core.DbObjectName)">
            <summary>
                Query for the designated FunctionBody
            </summary>
            <param name="function"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.ITenant.ExistingTableFor(System.Type)">
            <summary>
                Retrieve the existing Table for the document type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.Storage.Metadata.DocumentMetadata.Id">
            <summary>
            The identity of the document
            </summary>
        </member>
        <member name="P:Marten.Storage.Metadata.DocumentMetadata.LastModified">
            <summary>
            Timestamp of the last time this document was modified
            </summary>
        </member>
        <member name="P:Marten.Storage.Metadata.DocumentMetadata.CurrentVersion">
            <summary>
            The current version of this document in the database
            </summary>
        </member>
        <member name="P:Marten.Storage.Metadata.DocumentMetadata.DotNetType">
            <summary>
            The full name of the .Net type that was persisted
            </summary>
        </member>
        <member name="P:Marten.Storage.Metadata.DocumentMetadata.DocumentType">
            <summary>
            If the document is part of a type hierarchy, this designates
            Marten's internal name for the sub type
            </summary>
        </member>
        <member name="P:Marten.Storage.Metadata.DocumentMetadata.Deleted">
            <summary>
            If soft-deleted, whether or not the document is marked as deleted
            </summary>
        </member>
        <member name="P:Marten.Storage.Metadata.DocumentMetadata.DeletedAt">
            <summary>
            If soft-deleted, the time at which the document was marked as deleted
            </summary>
        </member>
        <member name="P:Marten.Storage.Metadata.DocumentMetadata.TenantId">
            <summary>
            The stored tenant id of this document
            </summary>
        </member>
        <member name="P:Marten.Storage.Metadata.DocumentMetadata.CausationId">
            <summary>
            Optional metadata describing the causation id for this
            unit of work
            </summary>
        </member>
        <member name="P:Marten.Storage.Metadata.DocumentMetadata.CorrelationId">
            <summary>
            Optional metadata describing the correlation id for this
            unit of work
            </summary>
        </member>
        <member name="P:Marten.Storage.Metadata.DocumentMetadata.LastModifiedBy">
            <summary>
            Optional metadata describing the user name or
            process name for this unit of work
            </summary>
        </member>
        <member name="P:Marten.Storage.Metadata.DocumentMetadata.Headers">
            <summary>
            Optional, user defined headers
            </summary>
        </member>
        <member name="P:Marten.Storage.Metadata.MetadataColumn.Enabled">
            <summary>
            Is this metadata column enabled?
            </summary>
        </member>
        <member name="M:Marten.Storage.StorageFeatures.Add(Marten.Storage.IFeatureSchema)">
            <summary>
            Register custom storage features
            </summary>
            <param name="feature"></param>
        </member>
        <member name="M:Marten.Storage.StorageFeatures.Add``1">
            <summary>
            Register custom storage features by type. Type must have either a no-arg, public
            constructor or a constructor that takes in a single StoreOptions parameter
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Marten.Storage.StorageFeatures.FindFeature(System.Type)">
            <summary>
            Retrieve an IFeatureSchema for the designated type
            </summary>
            <param name="featureType"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.StorageFeatures.AllSchemaNames">
            <summary>
            All referenced schema names by this DocumentStore
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.StorageFeatures.IncludeDocumentMappingBuilders(Marten.Storage.StorageFeatures)">
            <summary>
            Used to support MartenRegistry.Include()
            </summary>
            <param name="includedStorage"></param>
        </member>
        <member name="F:Marten.Storage.TenancyStyle.Single">
            <summary>
            No multi-tenancy, the default mode
            </summary>
        </member>
        <member name="F:Marten.Storage.TenancyStyle.Conjoined">
            <summary>
            Multi-tenanted within the same database/schema through a tenant id
            </summary>
        </member>
        <member name="F:Marten.Storage.TenancyStyle.Separate">
            <summary>
            Multi-tenanted through separate databases or schemas
            </summary>
        </member>
        <member name="M:Marten.Storage.Tenant.OpenConnection(Marten.Services.CommandRunnerMode,System.Data.IsolationLevel,System.Nullable{System.Int32})">
            <summary>
                Directly open a managed connection to the underlying Postgresql database
            </summary>
            <param name="mode"></param>
            <param name="isolationLevel"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.Tenant.CreateConnection">
            <summary>
                Fetch a connection to the tenant database
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.Tenant.ResetHiloSequenceFloor``1(System.Int64)">
            <summary>
                Set the minimum sequence number for a Hilo sequence for a specific document type
                to the specified floor. Useful for migrating data between databases
            </summary>
            <typeparam name="T"></typeparam>
            <param name="floor"></param>
        </member>
        <member name="T:Marten.StoreOptions">
            <summary>
                StoreOptions supplies all the necessary configuration
                necessary to customize and bootstrap a working
                DocumentStore
            </summary>
        </member>
        <member name="F:Marten.StoreOptions.InitialData">
            <summary>
            Register "initial data loads" that will be applied to the DocumentStore when it is
            bootstrapped
            </summary>
        </member>
        <member name="F:Marten.StoreOptions.Listeners">
            <summary>
                Add, remove, or reorder global session listeners
            </summary>
        </member>
        <member name="F:Marten.StoreOptions.Schema">
            <summary>
                Modify the document and event store database mappings for indexes and searching options
            </summary>
        </member>
        <member name="F:Marten.StoreOptions.AutoCreateSchemaObjects">
            <summary>
                Whether or Marten should attempt to create any missing database schema objects at runtime. This
                property is "All" by default for more efficient development, but can be set to lower values for production usage.
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.Projections">
            <summary>
            Configuration for all event store projections
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.GeneratedCodeMode">
            <summary>
            Direct Marten to either generate code at runtime (Dynamic), or attempt to load types from the entry assembly
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.Storage">
            <summary>
            Access to adding custom schema features to this Marten-enabled Postgresql database
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.Advanced">
            <summary>
            Advanced configuration options for this DocumentStore
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.Events">
            <summary>
                Configuration of event streams and projections
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.Linq">
            <summary>
                Extension point to add custom Linq query parsers
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.Policies">
            <summary>
                Apply conventional policies to how documents are mapped
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.DatabaseSchemaName">
            <summary>
                Sets the database default schema name used to store the documents.
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.NameDataLength">
            <summary>
                Used to validate database object name lengths against Postgresql's NAMEDATALEN property to avoid
                Marten getting confused when comparing database schemas against the configuration. See
                https://www.postgresql.org/docs/current/static/sql-syntax-lexical.html
                for more information. This does NOT adjust NAMEDATALEN for you.
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.EnumStorage">
            <summary>
                Gets Enum values stored as either integers or strings. This is configured on your ISerializer
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.UpdateBatchSize">
            <summary>
                Sets the batch size for updating or deleting documents in IDocumentSession.SaveChanges() /
                IUnitOfWork.ApplyChanges()
            </summary>
        </member>
        <member name="M:Marten.StoreOptions.Serializer">
            <summary>
            Retrieve the currently configured serializer
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.StoreOptions.Logger">
            <summary>
            Retrieve the currently configured logger for this DocumentStore
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.StoreOptions.RetryPolicy">
            <summary>
            Retrieve the current retry policy for this DocumentStore
            </summary>
            <returns></returns>
        </member>
        <member name="P:Marten.StoreOptions.Tenancy">
            <summary>
            Get or set the tenancy model for this DocumentStore
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Marten.StoreOptions.CreateDatabasesForTenants(System.Action{Marten.Schema.IDatabaseCreationExpressions})" -->
        <member name="M:Marten.StoreOptions.Connection(System.String)">
            <summary>
                Supply the connection string to the Postgresql database
            </summary>
            <param name="connectionString"></param>
        </member>
        <member name="M:Marten.StoreOptions.Connection(System.Func{System.String})">
            <summary>
                Supply a source for the connection string to a Postgresql database
            </summary>
            <param name="connectionSource"></param>
        </member>
        <member name="M:Marten.StoreOptions.Connection(System.Func{Npgsql.NpgsqlConnection})">
            <summary>
                Supply a mechanism for resolving an NpgsqlConnection object to
                the Postgresql database
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:Marten.StoreOptions.Serializer(Marten.ISerializer)">
            <summary>
                Override the JSON serialization by ISerializer type
            </summary>
            <param name="serializer"></param>
        </member>
        <member name="M:Marten.StoreOptions.UseDefaultSerialization(Weasel.Core.EnumStorage,Marten.Casing,Marten.CollectionStorage,Marten.NonPublicMembersStorage,Marten.Services.Json.SerializerType)">
            <summary>
                Use the default serialization (ilmerged Newtonsoft.Json) with Enum values
                stored as either integers or strings
            </summary>
            <param name="enumStorage"></param>
            <param name="casing">Casing style to be used in serialization</param>
            <param name="collectionStorage">Allow to set collection storage as raw arrays (without explicit types)</param>
            <param name="nonPublicMembersStorage">Allow non public members to be used during deserialization</param>
        </member>
        <member name="M:Marten.StoreOptions.Serializer``1">
            <summary>
                Override the JSON serialization by an ISerializer of type "T"
            </summary>
            <typeparam name="T">The ISerializer type</typeparam>
        </member>
        <member name="M:Marten.StoreOptions.Logger(Marten.IMartenLogger)">
            <summary>
            Replace the Marten logging strategy
            </summary>
            <param name="logger"></param>
        </member>
        <member name="M:Marten.StoreOptions.RetryPolicy(Marten.IRetryPolicy)">
            <summary>
            Replace the Marten retry policy
            </summary>
            <param name="retryPolicy"></param>
        </member>
        <member name="M:Marten.StoreOptions.RegisterDocumentType``1">
            <summary>
                Force Marten to create document mappings for type T
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Marten.StoreOptions.RegisterDocumentType(System.Type)">
            <summary>
                Force Marten to create a document mapping for the document type
            </summary>
            <param name="documentType"></param>
        </member>
        <member name="M:Marten.StoreOptions.RegisterDocumentTypes(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
                Force Marten to create document mappings for all the given document types
            </summary>
            <param name="documentTypes"></param>
        </member>
        <member name="M:Marten.StoreOptions.RegisterCompiledQueryType(System.Type)">
            <summary>
            Register a compiled query type for the "generate ahead" code generation strategy
            </summary>
            <param name="queryType"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Marten.StoreOptions.Validate">
            <summary>
                Validate that minimal options to initialize a document store have been specified
            </summary>
        </member>
        <member name="M:Marten.StoreOptions.ChildTypeMappingFor(System.Type)">
            <summary>
                These mappings should only be used for Linq querying within the SelectMany() body
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.StoreOptions.PoliciesExpression.OnDocuments``1">
            <summary>
                Add a pre-built Marten document policy
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.StoreOptions.PoliciesExpression.OnDocuments(Marten.IDocumentPolicy)">
            <summary>
                Add a pre-built Marten document policy
            </summary>
            <param name="policy"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.StoreOptions.PoliciesExpression.ForAllDocuments(System.Action{Marten.Schema.DocumentMapping})">
            <summary>
                Apply configuration to the persistence of all Marten document
                types
            </summary>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.StoreOptions.PoliciesExpression.AllDocumentsAreMultiTenanted">
            <summary>
                Unless explicitly marked otherwise, all documents should
                use conjoined multi-tenancy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.StoreOptions.PoliciesExpression.AllDocumentsSoftDeleted">
            <summary>
            Unless explicitly marked otherwise, all documents should
            be soft-deleted
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.StoreOptions.PoliciesExpression.DisableInformationalFields">
            <summary>
                Turn off the informational metadata columns
                in storage like the last modified, version, and
                dot net type for leaner storage
            </summary>
        </member>
        <member name="P:Marten.IReadOnlyAdvancedOptions.DuplicatedFieldEnumStorage">
            <summary>
                Sets Enum values stored as either integers or strings for DuplicatedField.
            </summary>
        </member>
        <member name="P:Marten.IReadOnlyAdvancedOptions.DuplicatedFieldUseTimestampWithoutTimeZoneForDateTime">
            <summary>
                Decides if `timestamp without time zone` database type should be used for `DateTime` DuplicatedField.
            </summary>
        </member>
        <member name="P:Marten.IReadOnlyAdvancedOptions.HiloSequenceDefaults">
            <summary>
                Global default parameters for Hilo sequences within the DocumentStore. Can be overridden per document
                type as well
            </summary>
        </member>
        <member name="P:Marten.IReadOnlyAdvancedOptions.DefaultTenantUsageEnabled">
            <summary>
                Option to enable or disable usage of default tenant when using multi-tenanted documents
            </summary>
        </member>
        <member name="P:Marten.AdvancedOptions.HiloSequenceDefaults">
            <summary>
                Global default parameters for Hilo sequences within the DocumentStore. Can be overridden per document
                type as well
            </summary>
        </member>
        <member name="P:Marten.AdvancedOptions.DdlRules">
            <summary>
                Allows you to modify how the DDL for document tables and upsert functions is
                written
            </summary>
        </member>
        <member name="P:Marten.AdvancedOptions.DuplicatedFieldEnumStorage">
            <summary>
                Sets Enum values stored as either integers or strings for DuplicatedField.
            </summary>
        </member>
        <member name="P:Marten.AdvancedOptions.DuplicatedFieldUseTimestampWithoutTimeZoneForDateTime">
            <summary>
                Decides if `timestamp without time zone` database type should be used for `DateTime` DuplicatedField.
            </summary>
        </member>
        <member name="P:Marten.AdvancedOptions.DefaultTenantUsageEnabled">
            <summary>
                Option to enable or disable usage of default tenant when using multi-tenanted documents
            </summary>
        </member>
        <member name="T:Marten.Util.ExpressionCompiler">
            <summary>Compiles expression to delegate by emitting the IL directly.
            The emitter is ~20 times faster than Expression.Compile.</summary>
        </member>
        <member name="M:Marten.Util.ExpressionCompiler.Compile``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>First tries to compile fast and if failed (null result), then falls back to Expression.Compile.</summary>
            <typeparam name="T">Type of compiled delegate return result.</typeparam>
            <param name="lambdaExpr">Expr to compile.</param>
            <returns>Compiled delegate.</returns>
        </member>
        <member name="M:Marten.Util.ExpressionCompiler.Compile``1(System.Linq.Expressions.LambdaExpression)">
            <summary>Compiles lambda expression to <typeparamref name="TDelegate"/>.</summary>
            <typeparam name="TDelegate">The compatible delegate type, otherwise case will throw.</typeparam>
            <param name="lambdaExpr">Lambda expression to compile.</param>
            <returns>Compiled delegate.</returns>
        </member>
        <member name="M:Marten.Util.ExpressionCompiler.TryCompile``1(System.Linq.Expressions.LambdaExpression)">
            <summary>Tries to compile lambda expression to <typeparamref name="TDelegate"/>.</summary>
            <typeparam name="TDelegate">The compatible delegate type, otherwise case will throw.</typeparam>
            <param name="lambdaExpr">Lambda expression to compile.</param>
            <returns>Compiled delegate.</returns>
        </member>
        <member name="M:Marten.Util.ExpressionCompiler.TryCompile``1(System.Linq.Expressions.Expression,System.Collections.Generic.IList{System.Linq.Expressions.ParameterExpression},System.Type[],System.Type)">
            <summary>Compiles expression to delegate by emitting the IL.
            If sub-expressions are not supported by emitter, then the method returns null.
            The usage should be calling the method, if result is null then calling the Expression.Compile.</summary>
            <param name="bodyExpr">Lambda body.</param>
            <param name="paramExprs">Lambda parameter expressions.</param>
            <param name="paramTypes">The types of parameters.</param>
            <param name="returnType">The return type.</param>
            <returns>Result delegate or null, if unable to compile.</returns>
        </member>
        <member name="T:Marten.Util.ExpressionCompiler.EmittingVisitor">
            <summary>Supports emitting of selected expressions, e.g. lambdaExpr are not supported yet.
            When emitter find not supported expression it will return false from <see cref="M:Marten.Util.ExpressionCompiler.EmittingVisitor.TryEmit(System.Linq.Expressions.Expression,System.Collections.Generic.IList{System.Linq.Expressions.ParameterExpression},System.Reflection.Emit.ILGenerator,Marten.Util.ExpressionCompiler.ClosureInfo)"/>, so I could fallback
            to normal and slow Expression.Compile.</summary>
        </member>
    </members>
</doc>
